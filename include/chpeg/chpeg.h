#define CHPEG_AMALGAMATION

//
// chpeg: util.h {
//

#ifndef CHPEG_UTIL_H
#define CHPEG_UTIL_H

#ifndef CHPEG_API
#define CHPEG_API extern
#define CHPEG_DEF
#endif

#include <stddef.h>

#ifndef CHPEG_MALLOC
CHPEG_API void *chpeg_malloc(size_t sz);
CHPEG_API void *chpeg_realloc(void *prev_ptr, size_t sz);
CHPEG_API void *chpeg_calloc(size_t count, size_t sz);
CHPEG_API void chpeg_free(void *ptr);
#define CHPEG_MALLOC(sz) chpeg_malloc(sz)
#define CHPEG_REALLOC(ptr, sz) chpeg_realloc(ptr, sz)
#define CHPEG_CALLOC(count, sz) chpeg_calloc(count, sz)
#define CHPEG_FREE(ptr) chpeg_free(ptr)
#endif

CHPEG_API char *chpeg_esc_bytes(const unsigned char *bytes, int length, int limit);
CHPEG_API int chpeg_read_file(const char *filename, unsigned char **data, size_t *length);

#endif // #ifndef CHPEG_UTIL_H

// } chpeg: util.h

//
// chpeg: opcodes.h {
//

#ifndef CHPEG_OPCODES_H
#define CHPEG_OPCODES_H

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_util.h"
#endif

enum ChpegOp
{
    CHPEG_OP_GOTO,
    CHPEG_OP_IDENT,
    CHPEG_OP_ISUCC,
    CHPEG_OP_IFAIL,
    CHPEG_OP_RSBEG,
    CHPEG_OP_RQBEG,
    CHPEG_OP_CHOICE,
    CHPEG_OP_CISUCC,
    CHPEG_OP_CFAIL,
    CHPEG_OP_CIFAIL,
    CHPEG_OP_RPBEG,
    CHPEG_OP_RPMAT,
    CHPEG_OP_RPDONE,
    CHPEG_OP_RSMAT,
    CHPEG_OP_RSDONE,
    CHPEG_OP_RQDONE,
    CHPEG_OP_RQMAT,
    CHPEG_OP_PREDA,
    CHPEG_OP_PREDN,
    CHPEG_OP_PMATCHF,
    CHPEG_OP_PNOMATF,
    CHPEG_OP_PMATCHS,
    CHPEG_OP_PNOMATS,
    CHPEG_OP_CHRCLS,
    CHPEG_OP_LIT,
    CHPEG_OP_LIT_NC,
    CHPEG_OP_DOT,
    CHPEG_OP_SUCC,
    CHPEG_OP_FAIL,

#ifdef CHPEG_EXTENSIONS
    CHPEG_OP_TRIM,
    CHPEG_OP_TRIMS,
    CHPEG_OP_TRIMF,
#endif

    CHPEG_NUM_OPS
};

CHPEG_API const char *Chpeg_op_names[CHPEG_NUM_OPS];

static inline const char *Chpeg_op_name(int op)
{
    return (op >= 0 && op < CHPEG_NUM_OPS) ? Chpeg_op_names[op] : "N/A";
}

#endif // #ifndef CHPEG_OPCODES_H

// } chpeg: opcodes.h

//
// chpeg: bytecode.h {
//

#ifndef CHPEG_BYTECODE_H
#define CHPEG_BYTECODE_H

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_util.h"
#endif

#include <stdio.h>

#define CHPEG_INST(op, arg) (((arg) << 8) | (op))
#define CHPEG_INST_OP(inst) (inst & 0xff)
#define CHPEG_INST_ARG(inst) (inst >> 8)

//
// Byte Code
//

typedef struct _ChpegByteCode
{
    int num_defs;
    char **def_names;
    int *def_flags;
    int *def_addrs;
    int num_instructions;
    int *instructions;
    int num_strings;
    unsigned char **strings;
    int *str_len;
} ChpegByteCode;

CHPEG_API ChpegByteCode *ChpegByteCode_new();
CHPEG_API void ChpegByteCode_free(ChpegByteCode *self);

CHPEG_API const char *ChpegByteCode_def_name(const ChpegByteCode *self, int index);
CHPEG_API int ChpegByteCode_compare(const ChpegByteCode *a, const ChpegByteCode *b);
CHPEG_API void ChpegByteCode_print_instructions(const ChpegByteCode *self);
CHPEG_API void ChpegByteCode_print_defs(const ChpegByteCode *self);
CHPEG_API void ChpegByteCode_print(const ChpegByteCode *self);
CHPEG_API void ChpegByteCode_output_h(const ChpegByteCode *self, FILE *fp,
    const char *basename, const char *varname, const char *prefix, const char *opcodes);
CHPEG_API void ChpegByteCode_output_c(const ChpegByteCode *self, FILE *fp,
    const char *basename, const char *varname);

CHPEG_API void ChpegByteCode_output_definition(const ChpegByteCode *self, int def_id, FILE *fp);

// node flags
enum ChpegFlags {
    // These flags correspond to Options used in the Definition:
    CHPEG_FLAG_STOP   = 1<<0,  // {S} stop automatic unwrapping, forcing this node to be a container
    CHPEG_FLAG_IGNORE = 1<<1,  // {I} deletes nodes matching this identifier
    CHPEG_FLAG_LEAF   = 1<<2,  // {L} collects this node and anything underneath as a final leaf (text) node

#ifdef CHPEG_EXTENSIONS
    // These flags are used internally
    CHPEG_FLAG_TRIMMED_LEFT  = 1<<3, // node has been 'trimmed left': offset has been adjusted
    CHPEG_FLAG_TRIMMED_RIGHT = 1<<4, // node has been 'trimmed right': length has been adjusted
#endif

};

#endif // #ifndef CHPEG_BYTECODE_H

// } chpeg: bytecode.h

//
// chpeg: chpeg_bytecode.h {
//

#ifndef CHPEG_CHPEG_BYTECODE_H
#define CHPEG_CHPEG_BYTECODE_H

// This is the default bytecode used by the chpeg compiler.
//
// This file is currently manually maintained. It was originally based on output from the Ruby bootstrap process. It serves a secondary purpose as a reference for the code generated by ChpegByteCode_output_h(). The output from that function should be identical to this file, if given ByteCode compiled from `grammars/chpeg.chpeg` as input, and basename="chpeg_bytecode".

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_util.h"
#include "chpeg/bytecode.h"
#include "chpeg/opcodes.h"
#endif

#define CHPEG_BC_GRAMMAR 0
#define CHPEG_BC_DEFINITION 1
#define CHPEG_BC_CHOICE 2
#define CHPEG_BC_SEQUENCE 3
#define CHPEG_BC_PREDICATE 4
#define CHPEG_BC_REPEAT 5
#define CHPEG_BC_PRIMARY 6
#define CHPEG_BC_OPTIONS 7
#define CHPEG_BC_IDENTIFIER 8
#define CHPEG_BC_LITERAL 9
#define CHPEG_BC_CHARCLASS 10
#define CHPEG_BC_CHARRANGE 11
#define CHPEG_BC_CHAR 12
#define CHPEG_BC_ESCCHAR 13
#define CHPEG_BC_OCTCHAR 14
#define CHPEG_BC_PLAINCHAR 15
#define CHPEG_BC_PREDOP 16
#define CHPEG_BC_REPOP 17
#define CHPEG_BC_DOT 18
#define CHPEG_BC_S 19

CHPEG_API const ChpegByteCode chpeg_bytecode;

#endif // #ifndef CHPEG_CHPEG_BYTECODE_H

// } chpeg: chpeg_bytecode.h

//
// chpeg: parser.h {
//

#ifndef CHPEG_PARSER_H
#define CHPEG_PARSER_H

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_util.h"
#include "chpeg/bytecode.h"
#endif

#include <stdio.h>

enum ChpegErrorCodes
{
    CHPEG_ERR_NONE = 0,
    CHPEG_ERR_PARSE_FAILED = 1,
    CHPEG_ERR_EXTRANEOUS_INPUT = 2,
    CHPEG_ERR_UNKNOWN_INSTRUCTION = 3,
    CHPEG_ERR_RUNAWAY = 4,
    CHPEG_ERR_STACK_OVERFLOW = 5,
    CHPEG_ERR_TREE_STACK_OVERFLOW = 6,
    CHPEG_ERR_STACK_UNDERFLOW = 7,
    CHPEG_ERR_TREE_STACK_UNDERFLOW = 8,
    CHPEG_ERR_UNEXPECTED_STACK_DATA = 9,
    CHPEG_ERR_UNEXPECTED_TREE_STACK_DATA = 10,
    CHPEG_ERR_INVALID_IDENTIFIER = 11,
};

struct _ChpegParser;

//
// Syntax tree ChpegNode
//

typedef struct _ChpegNode
{
    int def;
    size_t offset;
    size_t length;
    int flags;
    int num_children;
    struct _ChpegNode *head;
    struct _ChpegNode *next;
} ChpegNode;

CHPEG_API ChpegNode *ChpegNode_new(int def, size_t offset, size_t length, int flags);
CHPEG_API void ChpegNode_free(ChpegNode *self);
CHPEG_API ChpegNode *ChpegNode_push_child(ChpegNode *self, int def, size_t offset, size_t length, int flags);
CHPEG_API void ChpegNode_pop_child(ChpegNode *self);
CHPEG_API ChpegNode *ChpegNode_unwrap(ChpegNode *self);
CHPEG_API void ChpegNode_print(ChpegNode *self, struct _ChpegParser *parser, const unsigned char *input, int depth, FILE *fp);

//
// ChpegParser
//

typedef struct _ChpegParser
{
    const ChpegByteCode *bc;
    ChpegNode *tree_root;
    int max_tree_depth;
    int max_stack_size;
    size_t error_offset;
    int error_def;
    int error_parent_def;
    int error_inst;
    int error_expected;
    int parse_result;

#ifdef CHPEG_DEFINITION_TRACE
    int vm_count;
    int *def_count;
    int *def_succ_count;
    int *def_fail_count;
#endif

#if VM_TRACE
    int vm_trace;
#endif
#if VM_PRINT_TREE
    int vm_print_tree;
#endif

} ChpegParser;

#ifndef CHPEG_PARSER_MAX_STACK_SIZE
#define CHPEG_PARSER_MAX_TREE_DEPTH 256
#define CHPEG_PARSER_MAX_STACK_SIZE (CHPEG_PARSER_MAX_TREE_DEPTH * 8)
#endif /*CHPEG_PARSER_STACK_SIZE*/

CHPEG_API ChpegParser *ChpegParser_new(const ChpegByteCode *byte_code);
CHPEG_API void ChpegParser_free(ChpegParser *self);
CHPEG_API int ChpegParser_parse(ChpegParser *self, const unsigned char *input, size_t length, size_t *consumed);
CHPEG_API void ChpegParser_print_tree(ChpegParser *self, const unsigned char *input, FILE *fp);
CHPEG_API void ChpegParser_expected(ChpegParser *self, int parent_def, int def, int inst, size_t offset, int expected);
CHPEG_API void ChpegParser_print_error(ChpegParser *self, const unsigned char *input);

#endif // #ifndef CHPEG_PARSER_H

// } chpeg: parser.h

//
// chpeg: compiler.h {
//

#ifndef CHPEG_COMPILER_H
#define CHPEG_COMPILER_H

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_util.h"
#include "chpeg/bytecode.h"
#endif

#ifndef DEBUG_COMPILER
#define DEBUG_COMPILER 0
#endif

//
// Compiler
//

CHPEG_API int chpeg_compile(const unsigned char *input, size_t length,
    ChpegByteCode **bytecode_return, int verbose);

CHPEG_API const ChpegByteCode *chpeg_default_bytecode();

#endif // #ifndef CHPEG_COMPILER_H

// } chpeg: compiler.h

//
// chpeg: opcodes.c {
//

#ifndef CHPEG_AMALGAMATION
#include "chpeg/opcodes.h"
#endif

CHPEG_DEF const char *Chpeg_op_names[CHPEG_NUM_OPS] =
{
    "GOTO",
    "IDENT",
    "ISUCC",
    "IFAIL",
    "RSBEG",
    "RQBEG",
    "CHOICE",
    "CISUCC",
    "CFAIL",
    "CIFAIL",
    "RPBEG",
    "RPMAT",
    "RPDONE",
    "RSMAT",
    "RSDONE",
    "RQDONE",
    "RQMAT",
    "PREDA",
    "PREDN",
    "PMATCHF",
    "PNOMATF",
    "PMATCHS",
    "PNOMATS",
    "CHRCLS",
    "LIT",
    "LIT_NC",
    "DOT",
    "SUCC",
    "FAIL",
#ifdef CHPEG_EXTENSIONS
    "TRIM",
    "TRIMS",
    "TRIMF",
#endif
};

// } chpeg: opcodes.c

//
// chpeg: bytecode.c {
//

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#ifndef CHPEG_AMALGAMATION
#include "chpeg/util.h"
#include "chpeg/bytecode.h"
#include "chpeg/opcodes.h"
#endif

//
// ByteCode
//

CHPEG_API ChpegByteCode *ChpegByteCode_new()
{
    ChpegByteCode *self = (ChpegByteCode *)CHPEG_CALLOC(1, sizeof(ChpegByteCode));
    return self;
}

CHPEG_API void ChpegByteCode_free(ChpegByteCode *self)
{
    if (self == NULL) return;

    int i;

    if (self->num_defs > 0) {
        for (i = 0; i < self->num_defs; ++i) {
            CHPEG_FREE(self->def_names[i]);
        }
        if (self->def_names) {
            CHPEG_FREE(self->def_names);
            self->def_names = NULL;
        }
        if (self->def_flags) {
            CHPEG_FREE(self->def_flags);
            self->def_flags = NULL;
        }
        if (self->def_addrs) {
            CHPEG_FREE(self->def_addrs);
            self->def_addrs = NULL;
        }
        self->num_defs = 0;
    }

    if (self->num_instructions > 0) {
        if (self->instructions) {
            CHPEG_FREE(self->instructions);
            self->instructions = NULL;
        }
        self->num_instructions = 0;
    }

    if (self->num_strings > 0) {
        for (i = 0; i < self->num_strings; ++i) {
            CHPEG_FREE(self->strings[i]);
        }
        CHPEG_FREE(self->strings);
        CHPEG_FREE(self->str_len);
        self->num_strings = 0;
    }
    CHPEG_FREE(self);
}

CHPEG_API const char *ChpegByteCode_def_name(const ChpegByteCode *self, int index)
{
    if (index >= 0 && index < self->num_defs) {
        return self->def_names[index];
    }
    return 0;
}

CHPEG_API void ChpegByteCode_print_instructions(const ChpegByteCode *self)
{
    const char *arg_str = NULL;
    char *tmp = NULL;
    int op, arg;
    for (int i = 0; i < self->num_instructions; ++i) {
        op = CHPEG_INST_OP(self->instructions[i]);
        arg = CHPEG_INST_ARG(self->instructions[i]);
        switch (op) {
            case CHPEG_OP_IDENT:
            case CHPEG_OP_ISUCC:
            case CHPEG_OP_IFAIL:
#ifdef CHPEG_EXTENSIONS
            case CHPEG_OP_TRIM:
#endif
                arg_str = ChpegByteCode_def_name(self, arg);
                printf("CHPEG_INST %8d %12s %8d %s\n",
                    i, Chpeg_op_name(op), arg, arg_str ? arg_str : "<N/A>");
                break;
            case CHPEG_OP_LIT:
            case CHPEG_OP_CHRCLS:
                tmp = chpeg_esc_bytes(
                    self->strings[arg], self->str_len[arg], 256);
                printf("CHPEG_INST %8d %12s %8d \"%s\"\n", i, Chpeg_op_name(op), arg,
                    tmp ? tmp : "<NULL>");
                if (tmp) { CHPEG_FREE(tmp); tmp = NULL; }
                break;
            default:
                arg_str = "";
                printf("CHPEG_INST %8d %12s %8d\n", i, Chpeg_op_name(op), arg);
        }
    }
}

CHPEG_API void ChpegByteCode_print_defs(const ChpegByteCode *self)
{
    for (int i = 0; i < self->num_defs; ++i) {
        printf("DEF  %8d %12s %8d %6d\n", i, self->def_names[i], self->def_addrs[i], self->def_flags[i]);
    }
}

CHPEG_API void ChpegByteCode_print_strings(const ChpegByteCode *self)
{
    char *tmp;
    for (int i = 0; i < self->num_strings; ++i) {
        tmp = chpeg_esc_bytes(self->strings[i], self->str_len[i], 256);
        printf("STR  %8d %8d \"%s\"\n", i, self->str_len[i],
            tmp ? tmp : "<NULL>");
        if (tmp) { CHPEG_FREE(tmp); tmp = NULL; }
    }
}

CHPEG_API void ChpegByteCode_print(const ChpegByteCode *self)
{
    ChpegByteCode_print_defs(self);
    ChpegByteCode_print_instructions(self);
    ChpegByteCode_print_strings(self);
}

CHPEG_API void ChpegByteCode_output_h(const ChpegByteCode *self, FILE *fp,
    const char *basename, const char *varname, const char *prefix, const char *opcodes)
{
    int i, j, slen;

    if (prefix == NULL) {
        prefix = "chpeg_bc";
    }

    // guard
    char *preproc[3] = { "#ifndef", "#define", "#endif // #ifndef" };
    for (j = 0; j < 2; j++) {
        fprintf(fp, "%s ", preproc[j]);
        if (prefix) {
            slen = strlen(prefix);
            for (i = 0; i < slen; i++) {
                fputc(toupper(prefix[i]), fp);
            }
            fputc('_', fp);
        }
        if (basename) {
            slen = strlen(basename);
            for (i = 0; i < slen; i++) {
                fputc(toupper(basename[i]), fp);
            }
        }
        fprintf(fp, "_H\n");
    }

    fprintf(fp, "\n#ifndef CHPEG_AMALGAMATION\n");
    fprintf(fp, "#include \"chpeg/chpeg_util.h\"\n");
    fprintf(fp, "#include \"chpeg/bytecode.h\"\n");
    fprintf(fp, "#include \"%s\"\n", opcodes ? opcodes : "chpeg/opcodes.h");
    fprintf(fp, "#endif\n\n");

    // #define for each def name
    for (j = 0; j < self->num_defs; j++) {
        fprintf(fp, "#define ");
        if (prefix) {
            slen = strlen(prefix);
            for (i = 0; i < slen; i++) {
                fputc(toupper(prefix[i]), fp);
            }
            fputc('_', fp);
        }
        slen = strlen(self->def_names[j]);
        for (i = 0; i < slen; i++) {
            fputc(toupper(self->def_names[j][i]), fp);
        }
        fprintf(fp, " %d\n", j);
    }
    fputc('\n', fp);

    fprintf(fp, "CHPEG_API const ChpegByteCode %s;\n\n", varname ? varname : basename);

    fprintf(fp, "%s ", preproc[2]);
    if (prefix) {
        slen = strlen(prefix);
        for (i = 0; i < slen; i++) {
            fputc(toupper(prefix[i]), fp);
        }
        fputc('_', fp);
    }
    if (basename) {
        slen = strlen(basename);
        for (i = 0; i < slen; i++) {
            fputc(toupper(basename[i]), fp);
        }
    }
    fprintf(fp, "_H\n");
}

CHPEG_API void ChpegByteCode_output_c(const ChpegByteCode *self, FILE *fp,
    const char *basename, const char *varname)
{
    int i;
    char *str;

    fprintf(fp, "#ifndef CHPEG_AMALGAMATION\n#include \"%s.h\"\n#endif\n", basename);
    fprintf(fp, "\n");

    fprintf(fp, "CHPEG_DEF const ChpegByteCode %s = {\n", varname ? varname : basename);
    fprintf(fp, "  .num_defs = %d,\n", self->num_defs);

    fprintf(fp, "  .def_names = (char*[%d]) {", self->num_defs);
    for (i = 0; i < self->num_defs; i++) {
        fprintf(fp, "%s\"%s\"", i ? ", " : "", self->def_names[i]);
    }
    fprintf(fp, "},\n");

    fprintf(fp, "  .def_flags = (int[%d]) {", self->num_defs);
    for (i = 0; i < self->num_defs; i++) {
        fprintf(fp, "%s", i ? ", " : "");
        int flag_out = 0;
        if (self->def_flags[i] & 0x7) {
            if (self->def_flags[i] & CHPEG_FLAG_STOP) {
                fprintf(fp, "%sCHPEG_FLAG_STOP", flag_out ? " | " : "");
                flag_out = 1;
            }
            if (self->def_flags[i] & CHPEG_FLAG_IGNORE) {
                fprintf(fp, "%sCHPEG_FLAG_IGNORE", flag_out ? " | " : "");
                flag_out = 1;
            }
            if (self->def_flags[i] & CHPEG_FLAG_LEAF) {
                fprintf(fp, "%sCHPEG_FLAG_LEAF", flag_out ? " | " : "");
                flag_out = 1;
            }
        }
        else {
            fprintf(fp, "0");
        }
    }
    fprintf(fp, "},\n");

    fprintf(fp, "  .def_addrs = (int[%d]) {", self->num_defs);
    for (i = 0; i < self->num_defs; i++) {
        fprintf(fp, "%s%d", i ? ", " : "", self->def_addrs[i]);
    }
    fprintf(fp, "}, // presubtracted by 1\n");

    fprintf(fp, "  .num_instructions = %d,\n", self->num_instructions);

    fprintf(fp, "  .instructions = (int[%d]) {\n", self->num_instructions);
    const char *arg_str = NULL;
    int op, arg;
    for (int i = 0; i < self->num_instructions; i++) {
        op = CHPEG_INST_OP(self->instructions[i]);
        arg = CHPEG_INST_ARG(self->instructions[i]);
        switch (op) {
            case CHPEG_OP_IDENT:
            case CHPEG_OP_ISUCC:
            case CHPEG_OP_IFAIL:
#ifdef CHPEG_EXTENSIONS
            case CHPEG_OP_TRIM:
#endif
                arg_str = ChpegByteCode_def_name(self, arg);
                fprintf(fp, "  /* %5d */ CHPEG_INST(CHPEG_OP_%-12s, %8d), /* %s */\n",
                    i, Chpeg_op_name(op), arg, arg_str ? arg_str : "<N/A>");
                break;
            case CHPEG_OP_LIT:
            case CHPEG_OP_CHRCLS:
                str = chpeg_esc_bytes(self->strings[arg], self->str_len[arg], 40);
                fprintf(fp, "  /* %5d */ CHPEG_INST(CHPEG_OP_%-12s, %8d), /* \"%s\" */\n",
                    i, Chpeg_op_name(op), arg, str ? str : "<NULL>");
                if (str) { CHPEG_FREE(str); str = NULL; }
                break;
            default:
                arg_str = "";
                fprintf(fp, "  /* %5d */ CHPEG_INST(CHPEG_OP_%-12s, %8d),\n",
                    i, Chpeg_op_name(op), arg);
        }
    }
    fprintf(fp, "  },\n");

    fprintf(fp, "  .num_strings = %d,\n", self->num_strings);

    fprintf(fp, "  .strings = (unsigned char**)(char*[%d]) {", self->num_strings);
    for (i = 0; i < self->num_strings; i++) {
        str = chpeg_esc_bytes(self->strings[i], self->str_len[i], 0);
        fprintf(fp, "%s\"%s\"", i ? ", " : "", str);
        CHPEG_FREE(str);
    }
    fprintf(fp, "},\n");

    fprintf(fp, "  .str_len = (int[%d]) {", self->num_strings);
    for (i = 0; i < self->num_strings; i++) {
        fprintf(fp, "%s%d", i ? ", " : "", self->str_len[i]);
    }
    fprintf(fp, "}\n");

    fprintf(fp, "};\n");
}

CHPEG_API int ChpegByteCode_compare(const ChpegByteCode *a, const ChpegByteCode *b)
{
    int i;

    /* Defs */

    if (a->num_defs != b->num_defs) {
        printf("a->num_defs != b->num_defs\n");
        return 1;
    }
    for (i = 0; i < a->num_defs; ++i) {
        if (strcmp(a->def_names[i], b->def_names[i])) {
            printf("a->def_names[%d] = '%s'\n", i, a->def_names[i]);
            printf("b->def_names[%d] = '%s'\n", i, b->def_names[i]);
            return 2;
        }
    }
    for (i = 0; i < a->num_defs; ++i) {
        if (a->def_flags[i] != b->def_flags[i]) {
            printf("a->def_flags[%d] = %d\n", i, a->def_flags[i]);
            printf("b->def_flags[%d] = %d\n", i, b->def_flags[i]);
            return 3;
        }
    }
    for (i = 0; i < a->num_defs; ++i) {
        if (a->def_addrs[i] != b->def_addrs[i]) {
            printf("a->def_addrs[%d] = %d\n", i, a->def_addrs[i]);
            printf("b->def_addrs[%d] = %d\n", i, b->def_addrs[i]);
            return 4;
        }
    }

    /* Instructions */

    if (a->num_instructions != b->num_instructions) {
        printf("a->num_instructions != b->num_instructions\n");
        return 5;
    }
    for (i = 0; i < a->num_instructions; ++i) {
        if (a->instructions[i] != b->instructions[i]) {
            printf("a->instructions[%d] = %s %d\n", i,
                    Chpeg_op_name(CHPEG_INST_OP(a->instructions[i])), CHPEG_INST_ARG(a->instructions[i]));
            printf("b->instructions[%d] = %s %d\n", i,
                    Chpeg_op_name(CHPEG_INST_OP(b->instructions[i])), CHPEG_INST_ARG(b->instructions[i]));
            return 6;
        }
    }

    /* Strings */

    if (a->num_strings != b->num_strings) {
        printf("a->num_strings != b->num_strings\n");
        return 7;
    }

    for (i = 0; i < a->num_strings; ++i) {
        if (a->str_len[i] != b->str_len[i] || memcmp(a->strings[i], b->strings[i], a->str_len[i])) {
            char *tmp;
            tmp = chpeg_esc_bytes(a->strings[i], a->str_len[i], 256);
            printf("a->strings[%d] = \"%s\" (len=%d)\n", i,
                tmp ? tmp : "<NULL>", a->str_len[i]);
            if (tmp) { CHPEG_FREE(tmp); tmp = NULL; }
            tmp = chpeg_esc_bytes(b->strings[i], b->str_len[i], 256);
            printf("b->strings[%d] = \"%s\" (len=%d)\n", i,
                tmp ? tmp : "<NULL>", b->str_len[i]);
            if (tmp) { CHPEG_FREE(tmp); tmp = NULL; }
            return 8;
        }
    }

    return 0;
}

CHPEG_API void ChpegByteCode_output_definition(const ChpegByteCode *bc, int def_id, FILE *fp)
{
    fprintf(fp, "%s <- ", bc->def_names[def_id]);
    for(int i = bc->def_addrs[def_id]+1; i < bc->num_instructions; ++i) {
        int op = CHPEG_INST_OP(bc->instructions[i]);
        int arg = CHPEG_INST_ARG(bc->instructions[i]);
        switch(op) {
            case CHPEG_OP_IDENT: fprintf(fp, "%s ", bc->def_names[arg]); break;
            case CHPEG_OP_LIT:
            case CHPEG_OP_LIT_NC: {
                char *str = chpeg_esc_bytes(bc->strings[arg], bc->str_len[arg], 0);
                fprintf(fp, "\"%s\"%s ", str, (op == CHPEG_OP_LIT_NC) ? "i" : "");
                if (str) CHPEG_FREE(str);
            }
            break;
            case CHPEG_OP_CHRCLS: {
                char *str = chpeg_esc_bytes(bc->strings[arg], bc->str_len[arg], 0);
                fprintf(fp, "[%s] ", str);
                if (str) CHPEG_FREE(str);
            }
            break;

            case CHPEG_OP_RPBEG:
            case CHPEG_OP_RQBEG:
            case CHPEG_OP_RSBEG:
                fprintf(fp, "( "); break;

            case CHPEG_OP_RPDONE: fprintf(fp, ")+ "); break;
            case CHPEG_OP_RSDONE: fprintf(fp, ")* "); break;
            case CHPEG_OP_RQDONE: fprintf(fp, ")? "); break;

            case CHPEG_OP_PREDN: fprintf(fp, "! "); break;
            case CHPEG_OP_PREDA: fprintf(fp, "& "); break;
            case CHPEG_OP_DOT: fprintf(fp, ". "); break;


            //case CHPEG_OP_CHOICE: fprintf(fp, "/ "); break;
            case CHPEG_OP_CISUCC:
                if(CHPEG_INST_OP(bc->instructions[i+2]) != CHPEG_OP_CFAIL) //Not at the end of choice
                    fprintf(fp, "/ ");
            break;
            case CHPEG_OP_ISUCC: i = bc->num_instructions; //stop processing
        }
    }
}

// } chpeg: bytecode.c
//
// chpeg: chpeg_bytecode.c (
//

#ifndef CHPEG_AMALGAMATION
#include "chpeg/chpeg_bytecode.h"
#endif

// This is the default bytecode used by the chpeg compiler.
//
// This file is currently manually maintained. It was originally based on output from the Ruby bootstrap process. It serves a secondary purpose as a reference for the code generated by ChpegByteCode_output_c(). The output from that function should be identical to this file except for the formatting and comments in the instructions output, if given ByteCode compiled from `grammars/chpeg.chpeg` as input, and basename="chpeg_bytecode".

CHPEG_DEF const ChpegByteCode chpeg_bytecode = {
  .num_defs = 20,
  .def_names = (char*[20]) {"Grammar", "Definition", "Choice", "Sequence", "Predicate", "Repeat", "Primary", "Options", "Identifier", "Literal", "CharClass", "CharRange", "Char", "EscChar", "OctChar", "PlainChar", "PredOp", "RepOp", "Dot", "S"},
  .def_flags = (int[20]) {CHPEG_FLAG_STOP, 0, 0, 0, 0, 0, 0, 0, CHPEG_FLAG_LEAF, CHPEG_FLAG_STOP, CHPEG_FLAG_STOP, 0, 0, CHPEG_FLAG_LEAF, CHPEG_FLAG_LEAF, CHPEG_FLAG_LEAF, CHPEG_FLAG_LEAF, CHPEG_FLAG_LEAF, CHPEG_FLAG_LEAF, CHPEG_FLAG_IGNORE},
  .def_addrs = (int[20]) {2, 15, 42, 55, 62, 73, 84, 129, 136, 145, 181, 197, 218, 234, 240, 265, 273, 277, 281, 285}, // presubtracted by 1
  .num_instructions = 315,
  .instructions = (int[315]) {
  /*     0 <:Grammar 0 (Grammar) []>                */ CHPEG_INST(CHPEG_OP_IDENT, 0),
  /*     1 <:Grammar 0 (Grammar) []>                */ CHPEG_INST(CHPEG_OP_FAIL, 0),
  /*     2 <:Grammar 0 (Grammar) []>                */ CHPEG_INST(CHPEG_OP_SUCC, 0),
  /*     3 <---:Identifier 4 (Grammar[0]) "S">      */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*     4 <---:Identifier 4 (Grammar[0]) "S">      */ CHPEG_INST(CHPEG_OP_GOTO, 14),
  /*     5 <---:Repeat 5 (Grammar[1]) []>           */ CHPEG_INST(CHPEG_OP_RPBEG, 0),
  /*     6 <----:Identifier 6 (Grammar[1][0]) "Definition"> */ CHPEG_INST(CHPEG_OP_IDENT, 1),
  /*     7 <----:Identifier 6 (Grammar[1][0]) "Definition"> */ CHPEG_INST(CHPEG_OP_GOTO, 8),
  /*     8 <---:Repeat 5 (Grammar[1]) []>           */ CHPEG_INST(CHPEG_OP_RPMAT, 5),
  /*     9 <---:Repeat 5 (Grammar[1]) []>           */ CHPEG_INST(CHPEG_OP_RPDONE, 14),
  /*    10 <---:Predicate 7 (Grammar[2]) []>        */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*    11 <----:Dot 8 (Grammar[2][0]) ".">         */ CHPEG_INST(CHPEG_OP_DOT, 12),
  /*    12 <---:Predicate 7 (Grammar[2]) []>        */ CHPEG_INST(CHPEG_OP_PMATCHF, 14),
  /*    13 <---:Predicate 7 (Grammar[2]) []>        */ CHPEG_INST(CHPEG_OP_PNOMATS, 14),
  /*    14 <-:Definition 1 (def:Grammar) []> {S}    */ CHPEG_INST(CHPEG_OP_ISUCC, 0),
  /*    15 <-:Definition 1 (def:Grammar) []> {S}    */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    16 <---:Identifier 12 (Definition[0]) "Identifier"> */ CHPEG_INST(CHPEG_OP_IDENT, 8),
  /*    17 <---:Identifier 12 (Definition[0]) "Identifier"> */ CHPEG_INST(CHPEG_OP_GOTO, 41),
  /*    18 <---:Identifier 13 (Definition[1]) "S">  */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    19 <---:Identifier 13 (Definition[1]) "S">  */ CHPEG_INST(CHPEG_OP_GOTO, 41),
  /*    20 <---:Repeat 14 (Definition[2]) []>       */ CHPEG_INST(CHPEG_OP_RQBEG, 0),
  /*    21 <-----:Literal  (Definition[2][0][0]) "{"> */ CHPEG_INST(CHPEG_OP_LIT, 0),
  /*    22 <-----:Literal  (Definition[2][0][0]) "{"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    23 <-----:Identifier 16 (Definition[2][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    24 <-----:Identifier 16 (Definition[2][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    25 <-----:Identifier 17 (Definition[2][0][2]) "Options"> */ CHPEG_INST(CHPEG_OP_IDENT, 7),
  /*    26 <-----:Identifier 17 (Definition[2][0][2]) "Options"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    27 <-----:Identifier 18 (Definition[2][0][3]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    28 <-----:Identifier 18 (Definition[2][0][3]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    29 <-----:Literal  (Definition[2][0][4]) "}"> */ CHPEG_INST(CHPEG_OP_LIT, 1),
  /*    30 <-----:Literal  (Definition[2][0][4]) "}"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    31 <-----:Identifier 19 (Definition[2][0][5]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    32 <-----:Identifier 19 (Definition[2][0][5]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 33),
  /*    33 <---:Repeat 14 (Definition[2]) []>       */ CHPEG_INST(CHPEG_OP_RQMAT, 0),
  /*    34 <---:Repeat 14 (Definition[2]) []>       */ CHPEG_INST(CHPEG_OP_RQDONE, 0),
  /*    35 <---:Literal  (Definition[3]) "<-">      */ CHPEG_INST(CHPEG_OP_LIT, 2),
  /*    36 <---:Literal  (Definition[3]) "<-">      */ CHPEG_INST(CHPEG_OP_GOTO, 41),
  /*    37 <---:Identifier 20 (Definition[4]) "S">  */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    38 <---:Identifier 20 (Definition[4]) "S">  */ CHPEG_INST(CHPEG_OP_GOTO, 41),
  /*    39 <---:Identifier 21 (Definition[5]) "Choice"> */ CHPEG_INST(CHPEG_OP_IDENT, 2),
  /*    40 <---:Identifier 21 (Definition[5]) "Choice"> */ CHPEG_INST(CHPEG_OP_GOTO, 41),
  /*    41 <-:Definition 9 (def:Definition) []> {}  */ CHPEG_INST(CHPEG_OP_ISUCC, 1),
  /*    42 <-:Definition 9 (def:Definition) []> {}  */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    43 <---:Identifier 25 (Choice[0]) "Sequence"> */ CHPEG_INST(CHPEG_OP_IDENT, 3),
  /*    44 <---:Identifier 25 (Choice[0]) "Sequence"> */ CHPEG_INST(CHPEG_OP_GOTO, 54),
  /*    45 <---:Repeat 26 (Choice[1]) []>           */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*    46 <-----:Literal  (Choice[1][0][0]) "/">   */ CHPEG_INST(CHPEG_OP_LIT, 3),
  /*    47 <-----:Literal  (Choice[1][0][0]) "/">   */ CHPEG_INST(CHPEG_OP_GOTO, 52),
  /*    48 <-----:Identifier 28 (Choice[1][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    49 <-----:Identifier 28 (Choice[1][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 52),
  /*    50 <-----:Identifier 29 (Choice[1][0][2]) "Sequence"> */ CHPEG_INST(CHPEG_OP_IDENT, 3),
  /*    51 <-----:Identifier 29 (Choice[1][0][2]) "Sequence"> */ CHPEG_INST(CHPEG_OP_GOTO, 52),
  /*    52 <---:Repeat 26 (Choice[1]) []>           */ CHPEG_INST(CHPEG_OP_RSMAT, 45),
  /*    53 <---:Repeat 26 (Choice[1]) []>           */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*    54 <-:Definition 22 (def:Choice) []> {}     */ CHPEG_INST(CHPEG_OP_ISUCC, 2),
  /*    55 <-:Definition 22 (def:Choice) []> {}     */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    56 <--:Repeat 32 (Sequence) []>             */ CHPEG_INST(CHPEG_OP_RPBEG, 0),
  /*    57 <---:Identifier 33 (Sequence[0]) "Predicate"> */ CHPEG_INST(CHPEG_OP_IDENT, 4),
  /*    58 <---:Identifier 33 (Sequence[0]) "Predicate"> */ CHPEG_INST(CHPEG_OP_GOTO, 59),
  /*    59 <--:Repeat 32 (Sequence) []>             */ CHPEG_INST(CHPEG_OP_RPMAT, 56),
  /*    60 <--:Repeat 32 (Sequence) []>             */ CHPEG_INST(CHPEG_OP_RPDONE, 61),
  /*    61 <-:Definition 30 (def:Sequence) []> {}   */ CHPEG_INST(CHPEG_OP_ISUCC, 3),
  /*    62 <-:Definition 30 (def:Sequence) []> {}   */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    63 <---:Repeat 37 (Predicate[0]) []>        */ CHPEG_INST(CHPEG_OP_RQBEG, 0),
  /*    64 <-----:Identifier 39 (Predicate[0][0][0]) "PredOp"> */ CHPEG_INST(CHPEG_OP_IDENT, 16),
  /*    65 <-----:Identifier 39 (Predicate[0][0][0]) "PredOp"> */ CHPEG_INST(CHPEG_OP_GOTO, 68),
  /*    66 <-----:Identifier 40 (Predicate[0][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    67 <-----:Identifier 40 (Predicate[0][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 68),
  /*    68 <---:Repeat 37 (Predicate[0]) []>        */ CHPEG_INST(CHPEG_OP_RQMAT, 0),
  /*    69 <---:Repeat 37 (Predicate[0]) []>        */ CHPEG_INST(CHPEG_OP_RQDONE, 0),
  /*    70 <---:Identifier 41 (Predicate[1]) "Repeat"> */ CHPEG_INST(CHPEG_OP_IDENT, 5),
  /*    71 <---:Identifier 41 (Predicate[1]) "Repeat"> */ CHPEG_INST(CHPEG_OP_GOTO, 72),
  /*    72 <-:Definition 34 (def:Predicate) []> {}  */ CHPEG_INST(CHPEG_OP_ISUCC, 4),
  /*    73 <-:Definition 34 (def:Predicate) []> {}  */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    74 <---:Identifier 45 (Repeat[0]) "Primary"> */ CHPEG_INST(CHPEG_OP_IDENT, 6),
  /*    75 <---:Identifier 45 (Repeat[0]) "Primary"> */ CHPEG_INST(CHPEG_OP_GOTO, 83),
  /*    76 <---:Repeat 46 (Repeat[1]) []>           */ CHPEG_INST(CHPEG_OP_RQBEG, 0),
  /*    77 <-----:Identifier 48 (Repeat[1][0][0]) "RepOp"> */ CHPEG_INST(CHPEG_OP_IDENT, 17),
  /*    78 <-----:Identifier 48 (Repeat[1][0][0]) "RepOp"> */ CHPEG_INST(CHPEG_OP_GOTO, 81),
  /*    79 <-----:Identifier 49 (Repeat[1][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    80 <-----:Identifier 49 (Repeat[1][0][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 81),
  /*    81 <---:Repeat 46 (Repeat[1]) []>           */ CHPEG_INST(CHPEG_OP_RQMAT, 0),
  /*    82 <---:Repeat 46 (Repeat[1]) []>           */ CHPEG_INST(CHPEG_OP_RQDONE, 0),
  /*    83 <-:Definition 42 (def:Repeat) []> {}     */ CHPEG_INST(CHPEG_OP_ISUCC, 5),
  /*    84 <-:Definition 42 (def:Repeat) []> {}     */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*    85 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*    86 <----:Identifier 54 (Primary[0][0]) "Identifier"> */ CHPEG_INST(CHPEG_OP_IDENT, 8),
  /*    87 <----:Identifier 54 (Primary[0][0]) "Identifier"> */ CHPEG_INST(CHPEG_OP_GOTO, 95),
  /*    88 <----:Identifier 55 (Primary[0][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*    89 <----:Identifier 55 (Primary[0][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 95),
  /*    90 <----:Predicate 56 (Primary[0][2]) []>   */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*    91 <-----:CharClass  (Primary[0][2][0]) []> */ CHPEG_INST(CHPEG_OP_CHRCLS, 4),
  /*    92 <-----:CharClass  (Primary[0][2][0]) []> */ CHPEG_INST(CHPEG_OP_GOTO, 93),
  /*    93 <----:Predicate 56 (Primary[0][2]) []>   */ CHPEG_INST(CHPEG_OP_PMATCHF, 95),
  /*    94 <----:Predicate 56 (Primary[0][2]) []>   */ CHPEG_INST(CHPEG_OP_PNOMATS, 95),
  /*    95 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 127),
  /*    96 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*    97 <----:Literal  (Primary[1][0]) "(">      */ CHPEG_INST(CHPEG_OP_LIT, 5),
  /*    98 <----:Literal  (Primary[1][0]) "(">      */ CHPEG_INST(CHPEG_OP_GOTO, 107),
  /*    99 <----:Identifier 58 (Primary[1][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*   100 <----:Identifier 58 (Primary[1][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 107),
  /*   101 <----:Identifier 59 (Primary[1][2]) "Choice"> */ CHPEG_INST(CHPEG_OP_IDENT, 2),
  /*   102 <----:Identifier 59 (Primary[1][2]) "Choice"> */ CHPEG_INST(CHPEG_OP_GOTO, 107),
  /*   103 <----:Literal  (Primary[1][3]) ")">      */ CHPEG_INST(CHPEG_OP_LIT, 6),
  /*   104 <----:Literal  (Primary[1][3]) ")">      */ CHPEG_INST(CHPEG_OP_GOTO, 107),
  /*   105 <----:Identifier 60 (Primary[1][4]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*   106 <----:Identifier 60 (Primary[1][4]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 107),
  /*   107 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 127),
  /*   108 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   109 <----:Identifier 62 (Primary[2][0]) "Literal"> */ CHPEG_INST(CHPEG_OP_IDENT, 9),
  /*   110 <----:Identifier 62 (Primary[2][0]) "Literal"> */ CHPEG_INST(CHPEG_OP_GOTO, 113),
  /*   111 <----:Identifier 63 (Primary[2][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*   112 <----:Identifier 63 (Primary[2][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 113),
  /*   113 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 127),
  /*   114 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   115 <----:Identifier 65 (Primary[3][0]) "CharClass"> */ CHPEG_INST(CHPEG_OP_IDENT, 10),
  /*   116 <----:Identifier 65 (Primary[3][0]) "CharClass"> */ CHPEG_INST(CHPEG_OP_GOTO, 119),
  /*   117 <----:Identifier 66 (Primary[3][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*   118 <----:Identifier 66 (Primary[3][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 119),
  /*   119 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 127),
  /*   120 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   121 <----:Identifier 68 (Primary[4][0]) "Dot"> */ CHPEG_INST(CHPEG_OP_IDENT, 18),
  /*   122 <----:Identifier 68 (Primary[4][0]) "Dot"> */ CHPEG_INST(CHPEG_OP_GOTO, 125),
  /*   123 <----:Identifier 69 (Primary[4][1]) "S"> */ CHPEG_INST(CHPEG_OP_IDENT, 19),
  /*   124 <----:Identifier 69 (Primary[4][1]) "S"> */ CHPEG_INST(CHPEG_OP_GOTO, 125),
  /*   125 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 127),
  /*   126 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   127 <--:Choice 52 (Primary) []>              */ CHPEG_INST(CHPEG_OP_CFAIL, 128),
  /*   128 <-:Definition 50 (def:Primary) []> {}    */ CHPEG_INST(CHPEG_OP_ISUCC, 6),
  /*   129 <-:Definition 50 (def:Primary) []> {}    */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   130 <--:Repeat 72 (Options) []>              */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   131 <---:CharClass  (Options[0]) []>         */ CHPEG_INST(CHPEG_OP_CHRCLS, 7),
  /*   132 <---:CharClass  (Options[0]) []>         */ CHPEG_INST(CHPEG_OP_GOTO, 133),
  /*   133 <--:Repeat 72 (Options) []>              */ CHPEG_INST(CHPEG_OP_RSMAT, 130),
  /*   134 <--:Repeat 72 (Options) []>              */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   135 <-:Definition 70 (def:Options) []> {}    */ CHPEG_INST(CHPEG_OP_ISUCC, 7),
  /*   136 <-:Definition 70 (def:Options) []> {}    */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   137 <---:CharClass  (Identifier[0]) []>      */ CHPEG_INST(CHPEG_OP_CHRCLS, 8),
  /*   138 <---:CharClass  (Identifier[0]) []>      */ CHPEG_INST(CHPEG_OP_GOTO, 144),
  /*   139 <---:Repeat 76 (Identifier[1]) []>       */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   140 <----:CharClass  (Identifier[1][0]) []>  */ CHPEG_INST(CHPEG_OP_CHRCLS, 9),
  /*   141 <----:CharClass  (Identifier[1][0]) []>  */ CHPEG_INST(CHPEG_OP_GOTO, 142),
  /*   142 <---:Repeat 76 (Identifier[1]) []>       */ CHPEG_INST(CHPEG_OP_RSMAT, 139),
  /*   143 <---:Repeat 76 (Identifier[1]) []>       */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   144 <-:Definition 73 (def:Identifier) []> {L} */ CHPEG_INST(CHPEG_OP_ISUCC, 8),
  /*   145 <-:Definition 73 (def:Identifier) []> {L} */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   146 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*   147 <----:CharClass  (Literal[0][0]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 10),
  /*   148 <----:CharClass  (Literal[0][0]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 161),
  /*   149 <----:Repeat 81 (Literal[0][1]) []>      */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   150 <------:Predicate 83 (Literal[0][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   151 <-------:CharClass  (Literal[0][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_CHRCLS, 10),
  /*   152 <-------:CharClass  (Literal[0][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_GOTO, 153),
  /*   153 <------:Predicate 83 (Literal[0][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PMATCHF, 157),
  /*   154 <------:Predicate 83 (Literal[0][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PNOMATS, 157),
  /*   155 <------:Identifier 84 (Literal[0][1][0][1]) "Char"> */ CHPEG_INST(CHPEG_OP_IDENT, 12),
  /*   156 <------:Identifier 84 (Literal[0][1][0][1]) "Char"> */ CHPEG_INST(CHPEG_OP_GOTO, 157),
  /*   157 <----:Repeat 81 (Literal[0][1]) []>      */ CHPEG_INST(CHPEG_OP_RSMAT, 149),
  /*   158 <----:Repeat 81 (Literal[0][1]) []>      */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   159 <----:CharClass  (Literal[0][2]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 10),
  /*   160 <----:CharClass  (Literal[0][2]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 161),
  /*   161 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 179),
  /*   162 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   163 <----:CharClass  (Literal[1][0]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 11),
  /*   164 <----:CharClass  (Literal[1][0]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 177),
  /*   165 <----:Repeat 86 (Literal[1][1]) []>      */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   166 <------:Predicate 88 (Literal[1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   167 <-------:CharClass  (Literal[1][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_CHRCLS, 11),
  /*   168 <-------:CharClass  (Literal[1][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_GOTO, 169),
  /*   169 <------:Predicate 88 (Literal[1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PMATCHF, 173),
  /*   170 <------:Predicate 88 (Literal[1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PNOMATS, 173),
  /*   171 <------:Identifier 89 (Literal[1][1][0][1]) "Char"> */ CHPEG_INST(CHPEG_OP_IDENT, 12),
  /*   172 <------:Identifier 89 (Literal[1][1][0][1]) "Char"> */ CHPEG_INST(CHPEG_OP_GOTO, 173),
  /*   173 <----:Repeat 86 (Literal[1][1]) []>      */ CHPEG_INST(CHPEG_OP_RSMAT, 165),
  /*   174 <----:Repeat 86 (Literal[1][1]) []>      */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   175 <----:CharClass  (Literal[1][2]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 11),
  /*   176 <----:CharClass  (Literal[1][2]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 177),
  /*   177 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CISUCC, 179),
  /*   178 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   179 <--:Choice 79 (Literal) []>              */ CHPEG_INST(CHPEG_OP_CFAIL, 180),
  /*   180 <-:Definition 77 (def:Literal) []> {S}   */ CHPEG_INST(CHPEG_OP_ISUCC, 9),
  /*   181 <-:Definition 77 (def:Literal) []> {S}   */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   182 <---:Literal  (CharClass[0]) "[">        */ CHPEG_INST(CHPEG_OP_LIT, 12),
  /*   183 <---:Literal  (CharClass[0]) "[">        */ CHPEG_INST(CHPEG_OP_GOTO, 196),
  /*   184 <---:Repeat 93 (CharClass[1]) []>        */ CHPEG_INST(CHPEG_OP_RPBEG, 0),
  /*   185 <-----:Predicate 95 (CharClass[1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   186 <------:Literal  (CharClass[1][0][0][0]) "]"> */ CHPEG_INST(CHPEG_OP_LIT, 13),
  /*   187 <------:Literal  (CharClass[1][0][0][0]) "]"> */ CHPEG_INST(CHPEG_OP_GOTO, 188),
  /*   188 <-----:Predicate 95 (CharClass[1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PMATCHF, 192),
  /*   189 <-----:Predicate 95 (CharClass[1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PNOMATS, 192),
  /*   190 <-----:Identifier 96 (CharClass[1][0][1]) "CharRange"> */ CHPEG_INST(CHPEG_OP_IDENT, 11),
  /*   191 <-----:Identifier 96 (CharClass[1][0][1]) "CharRange"> */ CHPEG_INST(CHPEG_OP_GOTO, 192),
  /*   192 <---:Repeat 93 (CharClass[1]) []>        */ CHPEG_INST(CHPEG_OP_RPMAT, 184),
  /*   193 <---:Repeat 93 (CharClass[1]) []>        */ CHPEG_INST(CHPEG_OP_RPDONE, 196),
  /*   194 <---:Literal  (CharClass[2]) "]">        */ CHPEG_INST(CHPEG_OP_LIT, 13),
  /*   195 <---:Literal  (CharClass[2]) "]">        */ CHPEG_INST(CHPEG_OP_GOTO, 196),
  /*   196 <-:Definition 90 (def:CharClass) []> {S} */ CHPEG_INST(CHPEG_OP_ISUCC, 10),
  /*   197 <-:Definition 90 (def:CharClass) []> {S} */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   198 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*   199 <----:Identifier 101 (CharRange[0][0]) "Char"> */ CHPEG_INST(CHPEG_OP_IDENT, 12),
  /*   200 <----:Identifier 101 (CharRange[0][0]) "Char"> */ CHPEG_INST(CHPEG_OP_GOTO, 210),
  /*   201 <----:Literal  (CharRange[0][1]) "-">    */ CHPEG_INST(CHPEG_OP_LIT, 14),
  /*   202 <----:Literal  (CharRange[0][1]) "-">    */ CHPEG_INST(CHPEG_OP_GOTO, 210),
  /*   203 <----:Predicate 102 (CharRange[0][2]) []> */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   204 <-----:Literal  (CharRange[0][2][0]) "]"> */ CHPEG_INST(CHPEG_OP_LIT, 13),
  /*   205 <-----:Literal  (CharRange[0][2][0]) "]"> */ CHPEG_INST(CHPEG_OP_GOTO, 206),
  /*   206 <----:Predicate 102 (CharRange[0][2]) []> */ CHPEG_INST(CHPEG_OP_PMATCHF, 210),
  /*   207 <----:Predicate 102 (CharRange[0][2]) []> */ CHPEG_INST(CHPEG_OP_PNOMATS, 210),
  /*   208 <----:Identifier 103 (CharRange[0][3]) "Char"> */ CHPEG_INST(CHPEG_OP_IDENT, 12),
  /*   209 <----:Identifier 103 (CharRange[0][3]) "Char"> */ CHPEG_INST(CHPEG_OP_GOTO, 210),
  /*   210 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CISUCC, 216),
  /*   211 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   212 <---:Identifier 104 (CharRange[1]) "Char"> {E} */ CHPEG_INST(CHPEG_OP_IDENT, 12),
  /*   213 <---:Identifier 104 (CharRange[1]) "Char"> {E} */ CHPEG_INST(CHPEG_OP_GOTO, 214),
  /*   214 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CISUCC, 216),
  /*   215 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   216 <--:Choice 99 (CharRange) []>            */ CHPEG_INST(CHPEG_OP_CFAIL, 217),
  /*   217 <-:Definition 97 (def:CharRange) []> {}  */ CHPEG_INST(CHPEG_OP_ISUCC, 11),
  /*   218 <-:Definition 97 (def:CharRange) []> {}  */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   219 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*   220 <---:Identifier 108 (Char[0]) "EscChar"> {E} */ CHPEG_INST(CHPEG_OP_IDENT, 13),
  /*   221 <---:Identifier 108 (Char[0]) "EscChar"> {E} */ CHPEG_INST(CHPEG_OP_GOTO, 222),
  /*   222 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CISUCC, 232),
  /*   223 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   224 <---:Identifier 109 (Char[1]) "OctChar"> {E} */ CHPEG_INST(CHPEG_OP_IDENT, 14),
  /*   225 <---:Identifier 109 (Char[1]) "OctChar"> {E} */ CHPEG_INST(CHPEG_OP_GOTO, 226),
  /*   226 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CISUCC, 232),
  /*   227 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   228 <---:Identifier 110 (Char[2]) "PlainChar"> {E} */ CHPEG_INST(CHPEG_OP_IDENT, 15),
  /*   229 <---:Identifier 110 (Char[2]) "PlainChar"> {E} */ CHPEG_INST(CHPEG_OP_GOTO, 230),
  /*   230 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CISUCC, 232),
  /*   231 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   232 <--:Choice 107 (Char) []>                */ CHPEG_INST(CHPEG_OP_CFAIL, 233),
  /*   233 <-:Definition 105 (def:Char) []> {}      */ CHPEG_INST(CHPEG_OP_ISUCC, 12),
  /*   234 <-:Definition 105 (def:Char) []> {}      */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   235 <---:Literal  (EscChar[0]) "\\">         */ CHPEG_INST(CHPEG_OP_LIT, 15),
  /*   236 <---:Literal  (EscChar[0]) "\\">         */ CHPEG_INST(CHPEG_OP_GOTO, 239),
  /*   237 <---:CharClass  (EscChar[1]) []>         */ CHPEG_INST(CHPEG_OP_CHRCLS, 16),
  /*   238 <---:CharClass  (EscChar[1]) []>         */ CHPEG_INST(CHPEG_OP_GOTO, 239),
  /*   239 <-:Definition 111 (def:EscChar) []> {L}  */ CHPEG_INST(CHPEG_OP_ISUCC, 13),
  /*   240 <-:Definition 111 (def:EscChar) []> {L}  */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   241 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*   242 <----:Literal  (OctChar[0][0]) "\\">     */ CHPEG_INST(CHPEG_OP_LIT, 15),
  /*   243 <----:Literal  (OctChar[0][0]) "\\">     */ CHPEG_INST(CHPEG_OP_GOTO, 250),
  /*   244 <----:CharClass  (OctChar[0][1]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 17),
  /*   245 <----:CharClass  (OctChar[0][1]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 250),
  /*   246 <----:CharClass  (OctChar[0][2]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 18),
  /*   247 <----:CharClass  (OctChar[0][2]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 250),
  /*   248 <----:CharClass  (OctChar[0][3]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 18),
  /*   249 <----:CharClass  (OctChar[0][3]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 250),
  /*   250 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CISUCC, 263),
  /*   251 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   252 <----:Literal  (OctChar[1][0]) "\\">     */ CHPEG_INST(CHPEG_OP_LIT, 15),
  /*   253 <----:Literal  (OctChar[1][0]) "\\">     */ CHPEG_INST(CHPEG_OP_GOTO, 261),
  /*   254 <----:CharClass  (OctChar[1][1]) []>     */ CHPEG_INST(CHPEG_OP_CHRCLS, 18),
  /*   255 <----:CharClass  (OctChar[1][1]) []>     */ CHPEG_INST(CHPEG_OP_GOTO, 261),
  /*   256 <----:Repeat 119 (OctChar[1][2]) []>     */ CHPEG_INST(CHPEG_OP_RQBEG, 0),
  /*   257 <-----:CharClass  (OctChar[1][2][0]) []> */ CHPEG_INST(CHPEG_OP_CHRCLS, 18),
  /*   258 <-----:CharClass  (OctChar[1][2][0]) []> */ CHPEG_INST(CHPEG_OP_GOTO, 259),
  /*   259 <----:Repeat 119 (OctChar[1][2]) []>     */ CHPEG_INST(CHPEG_OP_RQMAT, 0),
  /*   260 <----:Repeat 119 (OctChar[1][2]) []>     */ CHPEG_INST(CHPEG_OP_RQDONE, 0),
  /*   261 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CISUCC, 263),
  /*   262 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   263 <--:Choice 116 (OctChar) []>             */ CHPEG_INST(CHPEG_OP_CFAIL, 264),
  /*   264 <-:Definition 114 (def:OctChar) []> {L}  */ CHPEG_INST(CHPEG_OP_ISUCC, 14),
  /*   265 <-:Definition 114 (def:OctChar) []> {L}  */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   266 <---:Predicate 123 (PlainChar[0]) []>    */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   267 <----:Literal  (PlainChar[0][0]) "\\">   */ CHPEG_INST(CHPEG_OP_LIT, 15),
  /*   268 <----:Literal  (PlainChar[0][0]) "\\">   */ CHPEG_INST(CHPEG_OP_GOTO, 269),
  /*   269 <---:Predicate 123 (PlainChar[0]) []>    */ CHPEG_INST(CHPEG_OP_PMATCHF, 272),
  /*   270 <---:Predicate 123 (PlainChar[0]) []>    */ CHPEG_INST(CHPEG_OP_PNOMATS, 272),
  /*   271 <---:Dot 124 (PlainChar[1]) ".">         */ CHPEG_INST(CHPEG_OP_DOT, 272),
  /*   272 <-:Definition 120 (def:PlainChar) []> {L} */ CHPEG_INST(CHPEG_OP_ISUCC, 15),
  /*   273 <-:Definition 120 (def:PlainChar) []> {L} */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   274 <--:CharClass  (PredOp) []>              */ CHPEG_INST(CHPEG_OP_CHRCLS, 19),
  /*   275 <--:CharClass  (PredOp) []>              */ CHPEG_INST(CHPEG_OP_GOTO, 276),
  /*   276 <-:Definition 125 (def:PredOp) []> {L}   */ CHPEG_INST(CHPEG_OP_ISUCC, 16),
  /*   277 <-:Definition 125 (def:PredOp) []> {L}   */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   278 <--:CharClass  (RepOp) []>               */ CHPEG_INST(CHPEG_OP_CHRCLS, 20),
  /*   279 <--:CharClass  (RepOp) []>               */ CHPEG_INST(CHPEG_OP_GOTO, 280),
  /*   280 <-:Definition 127 (def:RepOp) []> {L}    */ CHPEG_INST(CHPEG_OP_ISUCC, 17),
  /*   281 <-:Definition 127 (def:RepOp) []> {L}    */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   282 <--:Literal  (Dot) ".">                  */ CHPEG_INST(CHPEG_OP_LIT, 21),
  /*   283 <--:Literal  (Dot) ".">                  */ CHPEG_INST(CHPEG_OP_GOTO, 284),
  /*   284 <-:Definition 129 (def:Dot) []> {L}      */ CHPEG_INST(CHPEG_OP_ISUCC, 18),
  /*   285 <-:Definition 129 (def:Dot) []> {L}      */ CHPEG_INST(CHPEG_OP_IFAIL, 0),
  /*   286 <--:Repeat 133 (S) []>                   */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   287 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CHOICE, 0),
  /*   288 <----:Repeat 135 (S[0][0]) []> {E}       */ CHPEG_INST(CHPEG_OP_RPBEG, 0),
  /*   289 <-----:CharClass  (S[0][0][0]) []>       */ CHPEG_INST(CHPEG_OP_CHRCLS, 22),
  /*   290 <-----:CharClass  (S[0][0][0]) []>       */ CHPEG_INST(CHPEG_OP_GOTO, 291),
  /*   291 <----:Repeat 135 (S[0][0]) []> {E}       */ CHPEG_INST(CHPEG_OP_RPMAT, 288),
  /*   292 <----:Repeat 135 (S[0][0]) []> {E}       */ CHPEG_INST(CHPEG_OP_RPDONE, 293),
  /*   293 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CISUCC, 310),
  /*   294 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   295 <-----:Literal  (S[0][1][0]) "#">        */ CHPEG_INST(CHPEG_OP_LIT, 23),
  /*   296 <-----:Literal  (S[0][1][0]) "#">        */ CHPEG_INST(CHPEG_OP_GOTO, 308),
  /*   297 <-----:Repeat 137 (S[0][1][1]) []>       */ CHPEG_INST(CHPEG_OP_RSBEG, 0),
  /*   298 <-------:Predicate 139 (S[0][1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PREDN, 0),
  /*   299 <--------:CharClass  (S[0][1][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_CHRCLS, 24),
  /*   300 <--------:CharClass  (S[0][1][1][0][0][0]) []> */ CHPEG_INST(CHPEG_OP_GOTO, 301),
  /*   301 <-------:Predicate 139 (S[0][1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PMATCHF, 304),
  /*   302 <-------:Predicate 139 (S[0][1][1][0][0]) []> */ CHPEG_INST(CHPEG_OP_PNOMATS, 304),
  /*   303 <-------:Dot 140 (S[0][1][1][0][1]) "."> */ CHPEG_INST(CHPEG_OP_DOT, 304),
  /*   304 <-----:Repeat 137 (S[0][1][1]) []>       */ CHPEG_INST(CHPEG_OP_RSMAT, 297),
  /*   305 <-----:Repeat 137 (S[0][1][1]) []>       */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   306 <-----:CharClass  (S[0][1][2]) []>       */ CHPEG_INST(CHPEG_OP_CHRCLS, 24),
  /*   307 <-----:CharClass  (S[0][1][2]) []>       */ CHPEG_INST(CHPEG_OP_GOTO, 308),
  /*   308 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CISUCC, 310),
  /*   309 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CIFAIL, 0),
  /*   310 <---:Choice 134 (S[0]) []>               */ CHPEG_INST(CHPEG_OP_CFAIL, 311),
  /*   311 <--:Repeat 133 (S) []>                   */ CHPEG_INST(CHPEG_OP_RSMAT, 286),
  /*   312 <--:Repeat 133 (S) []>                   */ CHPEG_INST(CHPEG_OP_RSDONE, 0),
  /*   313 <-:Definition 131 (def:S) []> {I}        */ CHPEG_INST(CHPEG_OP_ISUCC, 19),
  /*   314 <-:Definition 131 (def:S) []> {I}        */ CHPEG_INST(CHPEG_OP_IFAIL, 0)
  },
  .num_strings = 25,
  .strings = (unsigned char**)(char*[25]) {"{", "}", "<-", "/", "{<", "(", ")", "ILS", "a-zA-Z_", "a-zA-Z_0-9", "'", "\"", "[", "]", "-", "\\", "nrt'\"[]\\", "0-3", "0-7", "&!", "*+?", ".", " \t\r\n", "#", "\r\n"},
  .str_len = (int[25]) {1, 1, 2, 1, 2, 1, 1, 3, 7, 10, 1, 1, 1, 1, 1, 1, 8, 3, 3, 2, 3, 1, 4, 1, 2}
};

// ) chpeg: chpeg_bytecode.c

//
// chpeg: util.c {
//

#ifndef CHPEG_AMALGAMATION
#include "chpeg/util.h"
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

// escape bytes like a C literal string, optionally truncating to limit, adding "..." at the end
// caller must free() returned value
CHPEG_API char *chpeg_esc_bytes(const unsigned char *bytes, int length, int limit)
{
    static const char *hex_digit = "0123456789ABCDEF";
#ifdef CHPEG_HAS_EXTRA_ESCAPE
    static const char *esc_chars = "\\\"\a\b\e\f\t\v\r\n";
#else
    static const char *esc_chars = "\\\"\t\r\n";
#endif

    if (!bytes || length < 0) { return NULL; }
    if (limit > 0 && limit < 3) { return NULL; }

    int blen = 0, slen = 0, i = 0, trunc = 0, blimit = 0;
    unsigned char b = 0;
    char *res = NULL;

    for (i = 0; i < length; ++i) {
        blen = 1;
        b = bytes[i];
        if (b == 0 || strchr(esc_chars, b)) {
            blen = 2;
        }
        else if (b < 32 || b > 126) {
            blen = 4;
        }

        if (limit && slen + blen > limit - 3) {
            trunc = 1;
            break;
        }
        slen += blen;
    }

    blimit = i;
    if (trunc) { slen += 3; }

    res = (char *)CHPEG_MALLOC(slen + 1);
    char *p = res;

    for (i = 0; i < blimit; ++i) {
        b = bytes[i];
        if (b == 0) {
            *p++ = '\\';
            *p++ = '0';
        }
        else if (strchr(esc_chars, b)) {
            *p++ = '\\';
            switch (b) {
#ifdef CHPEG_HAS_EXTRA_ESCAPE
                case '\a': *p++ = 'a'; break;
                case '\b': *p++ = 'b'; break;
                case '\e': *p++ = 'e'; break;
                case '\f': *p++ = 'f'; break;
                case '\v': *p++ = 'v'; break;
#endif                
                case '\r': *p++ = 'r'; break;
                case '\t': *p++ = 't'; break;
                case '\n': *p++ = 'n'; break;
                default: *p++ = (char)b; break;
            }
        }
        else if (b < 32 || b > 126) {
            *p++ = '\\';
            *p++ = 'x';
            *p++ = hex_digit[(b >> 4) & 0xf];
            *p++ = hex_digit[b & 0xf];
        }
        else {
            *p++ = (char)b;
        }
    }
    if (trunc) { *p++ = '.'; *p++ = '.'; *p++ = '.'; }
    *p = '\0';
    return res;
}

#ifndef CHPEG_READ_FILE_BLOCKSIZE
#define CHPEG_READ_FILE_BLOCKSIZE 4096
#endif

#ifndef CHPEG_READ_FILE_INITIAL_SIZE
#define CHPEG_READ_FILE_INITIAL_SIZE 4096 * 4
#endif

CHPEG_API int chpeg_read_file(const char *filename, unsigned char **data, size_t *length)
{
    int ret = 0;
    size_t bsize = 0, remain = 0, bytes_read = 0, len = 0;
    unsigned char *buf = NULL, *p = NULL;
    FILE *fp;

    // return error if either data or length return address is NULL
    if (data == NULL || length == NULL) {
        return 1;
    }

    // read from stdin if filename is NULL or "-"
    if (filename == NULL || strcmp(filename, "-") == 0) {
        filename = NULL;
        fp = stdin;
    }
    // else, open file
    else {
        fp = fopen(filename, "r");
        if (fp == NULL) {
            perror(filename);
            ret = 1;
            goto cleanup;
        }
    }

    // initial allocation
    buf = CHPEG_MALLOC(CHPEG_READ_FILE_INITIAL_SIZE);
    if (buf == NULL) {
        perror("malloc");
        ret = 1;
        goto cleanup;
    }
    p = buf;
    bsize = remain = CHPEG_READ_FILE_INITIAL_SIZE;

    for (;;) {
        bytes_read = fread(p, 1, remain < CHPEG_READ_FILE_BLOCKSIZE ?
            remain : CHPEG_READ_FILE_BLOCKSIZE, fp);
        if (bytes_read > 0) {
            remain -= bytes_read;
            p += bytes_read;
            len += bytes_read;
            if (remain == 0) {
                buf = CHPEG_REALLOC(buf, bsize * 2);
                if (buf == NULL) {
                    perror("realloc");
                    ret = 1;
                    break;
                }
                p = buf + bsize;
                remain = bsize;
                bsize *= 2;
            }
        }
        else {
            if (feof(fp)) {
                ret = 0;
            }
            else if (ferror(fp)) {
                fprintf(stderr, "Error reading file: %s\n",
                    filename ? filename : "<stdin>");
                ret = 1;
            }
            else {
                fprintf(stderr, "Unknown error reading file: %s\n",
                    filename ? filename : "<stdin>");
                ret = 1;
            }
            break;
        }
    }

cleanup:
    if (filename && fp) { // close only if fopen'd a file
        fclose(fp);
    }
    if (ret) { // if we're returning error
        if (buf) {
            CHPEG_FREE(buf); // free the allocated buffer
        }
        *data = NULL;
        *length = 0;
    }
    else {
        if (len > CHPEG_READ_FILE_INITIAL_SIZE) {
            buf = CHPEG_REALLOC(buf, len);
        }
        *data = buf;
        *length = len;
    }
    return ret;
}

#ifndef CHPEG_NO_MALLOC_WRAPPER
CHPEG_API void *chpeg_malloc(size_t sz) {
    void *ptr = malloc(sz);
    if(!ptr) {
        fprintf(stderr, "Failed to allocate %zd bytes of memory", sz);
        exit(-1);
    }
    return ptr;
}

CHPEG_API void *chpeg_realloc(void *prev_ptr, size_t sz) {
    void *ptr = realloc(prev_ptr, sz);
    if(!ptr) {
        fprintf(stderr, "Failed to reallocate %zd bytes of memory", sz);
        exit(-1);
    }
    return ptr;
}

CHPEG_API void *chpeg_calloc(size_t count, size_t sz) {
    void *ptr = calloc(count, sz);
    if(!ptr) {
        fprintf(stderr, "Failed to allocate and initialize %zd bytes of memory", sz);
        exit(-1);
    }
    return ptr;
}

CHPEG_API void chpeg_free(void *ptr) {
    free(ptr);
}
#endif /*CHPEG_NO_MALLOC_WRAPPER*/
// } chpeg: util.c
//
// chpeg: parser.c {
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef CHPEG_AMALGAMATION
#include "chpeg/util.h"
#include "chpeg/parser.h"
#include "chpeg/opcodes.h"
#endif

#ifndef SANITY_CHECKS
#define SANITY_CHECKS 1
#endif

#ifndef DEBUG_ERRORS
#define DEBUG_ERRORS 0
#endif

// Set ERRORS to non-zero to enable error tracking. Without error tracking, errors are still detected, but it can't tell you where an error occurred.
#ifndef ERRORS
#define ERRORS 1
#endif

#ifndef ERRORS_PRED
#define ERRORS_PRED 1
#endif

#ifndef ERRORS_IDENT
#define ERRORS_IDENT 1
#endif

#ifndef ERRORS_TERMINALS
#define ERRORS_TERMINALS 1
#endif

#define ERROR_REPEAT_INHIBIT 0 // probably flawed idea or implementation, don't enable

// VM_TRACE:
// Set to non-zero to compile in support for tracing parser VM instruction execution.
// To use, set parser->vm_trace to non-zero before calling ChpegParser_parse()
#ifndef VM_TRACE
#define VM_TRACE 0
#endif

// VM_PRINT_TREE:
// Set to non-zero to compile in support for printing the parse tree as it is being built.
// To use, set parser->vm_print_tree to non-zero before calling ChpegParser_parse()
#ifndef VM_PRINT_TREE
#define VM_PRINT_TREE 0
#endif

//
// ChpegNode
//

CHPEG_API void ChpegNode_print(ChpegNode *self, ChpegParser *parser, const unsigned char *input, int depth, FILE *fp)
{
    int flags = self->flags;
    char *data = chpeg_esc_bytes(&input[self->offset], self->length, 40);
    const char *def_name = ChpegByteCode_def_name(parser->bc, self->def);

    if (depth == 0) {
        fprintf(fp, " offset   len     id dp flg ident \"data\"\n");
    }

    fprintf(fp, "%6zu %6zu %6d %2d %s%s%s %*s%s \"%s\"\n",
        self->offset,
        self->length,
        self->def,
        depth,
        flags & CHPEG_FLAG_STOP ? "S" : "-",
        flags & CHPEG_FLAG_IGNORE ? "I" : "-",
        flags & CHPEG_FLAG_LEAF ? "L" : "-",
        depth * 2, "",
        def_name ? def_name : "<N/A>",
        data ? data : "<NULL>"
        );

    if (data) { CHPEG_FREE(data); data = NULL; }
    for (ChpegNode *p = self->head; p; p = p->next) {
        ChpegNode_print(p, parser, input, depth + 1, fp);
    }
}

CHPEG_API ChpegNode *ChpegNode_new(int def, size_t offset, size_t length, int flags)
{
    ChpegNode *self = (ChpegNode *)CHPEG_MALLOC(sizeof(ChpegNode));
    self->def = def;
    self->offset = offset;
    self->length = length;
    self->flags = flags;
    self->num_children = 0;
    self->head = NULL;
    self->next = NULL;
    return self;
}

CHPEG_API void ChpegNode_free(ChpegNode *self)
{
    if (self) {
        ChpegNode *tmp;
        for (ChpegNode *p = self->head; p; p = tmp) {
            tmp = p->next;
            ChpegNode_free(p);
        }
        self->head = NULL;
        CHPEG_FREE(self);
    }
}

CHPEG_API ChpegNode *ChpegNode_push_child(ChpegNode *self, int def, size_t offset, size_t length, int flags)
{
    ChpegNode *node = ChpegNode_new(def, offset, length, flags);
    node->next = self->head;
    self->head = node;
    ++(self->num_children);
    return node;
}

CHPEG_API void ChpegNode_pop_child(ChpegNode *self)
{
    if (self->head) {
        ChpegNode *tmp = self->head;
        self->head = self->head->next;
        ChpegNode_free(tmp);
        --(self->num_children);
    }
}

// 'Unwrap' a ChpegNode, recursively removing unnecessary parent nodes containing only one child.
// In the process, this reverses the reverse node insertion used in tree building, so should only
// be called once on the tree root after a successful parse.
CHPEG_API ChpegNode *ChpegNode_unwrap(ChpegNode *self)
{
    if (!(self->flags & (CHPEG_FLAG_STOP | CHPEG_FLAG_LEAF)) && self->num_children == 1) {
        ChpegNode *tmp = ChpegNode_unwrap(self->head);
        self->head = NULL;
        ChpegNode_free(self);
        return tmp;
    }
    ChpegNode *p = self->head; self->head = NULL;
    ChpegNode *tmp;
    for (; p; p=tmp) {
        tmp = p->next;
        p = ChpegNode_unwrap(p);
        p->next = self->head;
        self->head = p;
    }
    return self;
}

//
// ChpegParser
//

CHPEG_API ChpegParser *ChpegParser_new(const ChpegByteCode *bc)
{
    ChpegParser *self = (ChpegParser *)CHPEG_MALLOC(sizeof(ChpegParser));

    self->bc = bc;
    self->tree_root = NULL;
    self->max_tree_depth = CHPEG_PARSER_MAX_TREE_DEPTH;
    self->max_stack_size = CHPEG_PARSER_MAX_STACK_SIZE;
    self->error_offset = 0;
    self->error_parent_def = -1;
    self->error_def = -1;
    self->error_inst = -1;
    self->error_expected = -1;

#ifdef CHPEG_DEFINITION_TRACE
    self->def_count = CHPEG_CALLOC(bc->num_defs, sizeof(int));
    self->def_succ_count = CHPEG_CALLOC(bc->num_defs, sizeof(int));
    self->def_fail_count = CHPEG_CALLOC(bc->num_defs, sizeof(int));
#endif

#if VM_TRACE
    self->vm_trace = 0;
#endif
#if VM_PRINT_TREE
    self->vm_print_tree = 0;
#endif

    return self;
}

CHPEG_API void ChpegParser_free(ChpegParser *self)
{
    if (self) {
        if (self->tree_root) {
            ChpegNode_free(self->tree_root);
            self->tree_root = NULL;
        }
#ifdef CHPEG_DEFINITION_TRACE
        CHPEG_FREE(self->def_count);
        CHPEG_FREE(self->def_succ_count);
        CHPEG_FREE(self->def_fail_count);
#endif
        CHPEG_FREE(self);
    }
}

CHPEG_API void ChpegParser_print_tree(ChpegParser *self, const unsigned char *input, FILE *fp)
{
#ifdef CHPEG_DEFINITION_TRACE
    int itotal_def_count = 0, itotal_def_succ_count = 0, itotal_def_fail_count = 0;
    for(int i=0; i < self->bc->num_defs; ++i) {
        itotal_def_count += self->def_count[i];
        itotal_def_succ_count += self->def_succ_count[i];
        itotal_def_fail_count += self->def_fail_count[i];
    }
    double dtotal_count = itotal_def_count;
    fprintf(fp, "%4s  %10s  %5s  %10s  %10s  %s\n", "id", "total", "%", "success", "fail", "definition");
    for(int i=0; i < self->bc->num_defs; ++i) {
        fprintf(fp, "%4.d  %10.d  %5.2f  %10.d  %10.d  ", i, self->def_count[i], (self->def_count[i]/dtotal_count)*100.0, self->def_succ_count[i], self->def_fail_count[i]);
        ChpegByteCode_output_definition(self->bc, i, fp);
        fprintf(fp, "\n");
    }
    fprintf(fp, "\n%4s  %10.d  %5s  %10.d  %10.d  Total counters\n", "", itotal_def_count, "", itotal_def_succ_count, itotal_def_fail_count);
    fprintf(fp, "\n%4s  %12s  %5s  %8.2f  %10.2f  %% success/fail\n\n", "", "", "", (itotal_def_succ_count/dtotal_count)*100.0, (itotal_def_fail_count/dtotal_count)*100.0);
    fprintf(fp, "Total VM loops %d\n\n", self->vm_count);
#endif
    ChpegNode_print(self->tree_root, self, input, 0, fp);
}

CHPEG_API void ChpegParser_expected(ChpegParser *self, int parent_def, int def, int inst, size_t offset, int expected)
{
    if (offset >= self->error_offset && !(def == 0 && inst == -1)) {
        self->error_offset = offset;
        self->error_parent_def = parent_def;
        self->error_def = def;
        self->error_inst = inst;
        self->error_expected = expected;
    }
}

CHPEG_API void ChpegParser_print_error(ChpegParser *self, const unsigned char *input)
{
#if ERRORS
    const char *parent_def_name = ChpegByteCode_def_name(self->bc, self->error_parent_def);
    const char *def_name = ChpegByteCode_def_name(self->bc, self->error_def);

    if (self->error_expected >= 0) {
        if (self->error_inst >= 0) {
            int op = CHPEG_INST_OP(self->error_inst);
            int arg = CHPEG_INST_ARG(self->error_inst);
            char *esc = NULL;
            const char *str = NULL;
            char buf[1024];
            switch (op) {
                case CHPEG_OP_DOT:
                    snprintf(buf, sizeof(buf), "character `%c`", input[self->error_offset]);
                    str = buf;
                    break;
                case CHPEG_OP_IDENT:
                    str = ChpegByteCode_def_name(self->bc, arg); break;
                case CHPEG_OP_LIT:
                    esc = chpeg_esc_bytes((unsigned char *)self->bc->strings[arg],
                        self->bc->str_len[arg], 20);
                    break;
                case CHPEG_OP_CHRCLS:
                    str = (const char*)self->bc->strings[arg];
                    break;
                default: // unhandled op, show instruction in <> for debugging
                    snprintf(buf, sizeof(buf), "unhandled op <%s>", Chpeg_op_names[op]);
                    str = buf;
                    break;
            }
            fprintf(stderr, "%s \"%s\" in %s at offset %lu\n",
                    self->error_expected ? "Expected" : "Unexpected",
                    str ? str : (esc ? esc : "<NULL>"),
                    def_name ? def_name : "<N/A>",
                    self->error_offset);
            if (esc) {
                CHPEG_FREE(esc);
                esc = NULL;
            }
        }
        else {
            if (parent_def_name) {
                fprintf(stderr, "%s %s in %s at offset %lu\n",
                        self->error_expected ? "Expected" : "Unexpected",
                        def_name ? def_name : "<N/A>",
                        parent_def_name ? parent_def_name : "<N/A>",
                        self->error_offset);
            }
            else {
                fprintf(stderr, "%s %s at offset %lu\n",
                        self->error_expected ? "Expected" : "Unexpected",
                        def_name ? def_name : "<N/A>",
                        self->error_offset);
            }
        }
    }
    else {
        fprintf(stderr, "No errors detected / tracked.\n");
    }
#else
    fprintf(stderr, "Error tracking disabled at compile time.\n");
#endif
}

// TODO: check sanity checks and overflow checks, make macros to make it easier
CHPEG_API int ChpegParser_parse(ChpegParser *self, const unsigned char *input, size_t length, size_t *consumed)
{
    int locked = 0, retval = 0;

#if ERRORS
    int err_locked = 0;
#endif

#if VM_PRINT_TREE
    int tree_changed = 0;
#endif

    //const int num_defs = self->bc->num_defs;
    //const char **def_names = (const char **)self->bc->def_names;
    const int *def_flags = self->bc->def_flags;
    const int *def_addrs = self->bc->def_addrs;
    const int *instructions = self->bc->instructions;
    //const int num_strings = self->bc->num_strings;
    const unsigned char **strings = (const unsigned char **)self->bc->strings;
    const int *str_len = self->bc->str_len;

    const int max_stack_size = self->max_stack_size;
    const int max_tree_depth = self->max_tree_depth;

#ifdef CHPEG_DEFINITION_TRACE
    memset(self->def_count, 0, sizeof(int)*self->bc->num_defs);
    memset(self->def_succ_count, 0, sizeof(int)*self->bc->num_defs);
    memset(self->def_fail_count, 0, sizeof(int)*self->bc->num_defs);
#endif

    size_t offset = 0;
    int op = 0, arg = 0, pc = 0;

    size_t stack[max_stack_size]; int top = -1;
    ChpegNode *tree_stack[max_tree_depth]; int tree_top = -1;

    self->tree_root = ChpegNode_new(0, 0, 0, 0);
    if (tree_top >= max_tree_depth - 2) return CHPEG_ERR_TREE_STACK_OVERFLOW;
    tree_stack[++tree_top] = self->tree_root;

#if SANITY_CHECKS || VM_TRACE
    unsigned long long cnt = 0, cnt_max = 0;
    const int num_instructions = self->bc->num_instructions;
    cnt_max = (length <= 2642245) ? (length < 128 ? 2097152 : length * length * length) : (unsigned long long)-1LL;
    for(cnt = 0; cnt < cnt_max && pc < num_instructions; ++cnt, ++pc)
#else
    for(;; ++pc)
#endif
    {
        op = CHPEG_INST_OP(instructions[pc]);
        arg = CHPEG_INST_ARG(instructions[pc]);

#ifdef CHPEG_DEFINITION_TRACE
        ++self->vm_count;
#endif

#if VM_TRACE
        if (self->vm_trace) {
            if (cnt == 0) {
                fprintf(stderr, "=     CNT   OFFSET       PC           OP   ARG\n");
            }
            char *tmp;
            const char *def_name;
            switch (op) {
                case CHPEG_OP_IDENT:
                case CHPEG_OP_ISUCC:
                case CHPEG_OP_IFAIL:
#ifdef CHPEG_EXTENSIONS
                case CHPEG_OP_TRIM:
#endif
                    def_name = ChpegByteCode_def_name(self->bc, arg);
                    fprintf(stderr, "=%8llu %8lu %8d %12s %5d %*s%s\n",
                        cnt, offset, pc, Chpeg_op_name(op), arg, tree_top*2, "",
                        def_name ? def_name : "<INVALID>");
                    def_name = NULL;
                    break;
                case CHPEG_OP_LIT:
                case CHPEG_OP_CHRCLS:
                    tmp = chpeg_esc_bytes(
                        strings[arg], str_len[arg], 28);
                    fprintf(stderr, "=%8llu %8lu %8d %12s %5d %*s\"%s\"\n",
                        cnt, offset, pc, Chpeg_op_name(op), arg, tree_top*2, "",
                        tmp ? tmp : "<NULL>");
                    CHPEG_FREE(tmp);
                    tmp = NULL;
                    break;
                default:
                    fprintf(stderr, "=%8llu %8lu %8d %12s %5d %*s-\n",
                        cnt, offset, pc, Chpeg_op_name(op), arg, tree_top*2, "");
            }
        }
#endif

#if VM_PRINT_TREE
        tree_changed = 0;
#endif

        // Note: don't return from inside this switch, set pc = -1, retval = return value, then break;
        // This is to allow finalization like tree printing (if enabled)

        switch (op) {
            case CHPEG_OP_GOTO: // arg = addr; GOTO addr; pc is set to addr
                pc = arg; break;

// Identifier
            case CHPEG_OP_IDENT: // arg = def; Identifier "call"; on success, next instruction skipped (See ISUCC, IFAIL)
                if (arg < 0) {
                    pc = -1; retval = CHPEG_ERR_INVALID_IDENTIFIER; break;
                }
                if (top >= max_stack_size - 4) { // pushes 3 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }
                if (!locked) {
                    if (tree_top >= max_tree_depth - 2) {
                        pc = -1; retval = CHPEG_ERR_TREE_STACK_OVERFLOW; break;
                    }
                    if (def_flags[arg] & (CHPEG_FLAG_LEAF | CHPEG_FLAG_IGNORE)) {
                        stack[++top] = 1; locked = 1; // s+1: locked
                    }
                    else {
                        stack[++top] = 0; // s+1: locked
                    }
                    tree_stack[tree_top+1] = ChpegNode_push_child(tree_stack[tree_top], arg, offset, 0, def_flags[arg]);
                    ++tree_top;
                }
                else {
                    stack[++top] = 0; // s+1: locked
                }
                stack[++top] = offset; // s+2: offset
                stack[++top] = pc; // s+3: pc
                pc = def_addrs[arg];
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
#ifdef CHPEG_DEFINITION_TRACE
                ++self->def_count[arg];
#endif
                break;

            case CHPEG_OP_ISUCC: // arg = def; Identifier "call" match success, "return", pc restored to pc+1, skipping next instruction
#if SANITY_CHECKS
                if (top < 2) { // pops 3 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
                pc = stack[top--] + 1; // s+2: offset
                --top; // s+1: locked
                if (stack[top--] == 1) { locked = 0; } // s+0: done popping stack
                if (!locked) {
#ifdef CHPEG_EXTENSIONS
                    // if we haven't set length by trimming right, set length
                    if ((tree_stack[tree_top]->flags & CHPEG_FLAG_TRIMMED_RIGHT) == 0)
                    {
#endif
                        tree_stack[tree_top]->length = offset - tree_stack[tree_top]->offset;
#ifdef CHPEG_EXTENSIONS
                    }
#endif
                    --tree_top;
                    if (def_flags[arg] & CHPEG_FLAG_IGNORE) {
#if SANITY_CHECKS
                        if (tree_top < 0) {
                            pc = -1; retval = CHPEG_ERR_TREE_STACK_UNDERFLOW; break;
                        }
#endif
                        ChpegNode_pop_child(tree_stack[tree_top]);
                    }
                }
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
#ifdef CHPEG_DEFINITION_TRACE
                ++self->def_succ_count[arg];
#endif
                break;

            case CHPEG_OP_IFAIL: // Identifier "call" match failure, "return", pc restored (next instruction not skipped)
#if SANITY_CHECKS
                if (top < 2) { // pops 3 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
                pc = stack[top--]; // top=s+2: offset
                offset = stack[top--]; // top=s+1: locked

#if ERRORS && ERRORS_IDENT
                if (!err_locked) { // Tracking errors here is probably bare minimum of usefulness
                    ChpegParser_expected(self,
                            tree_top > 0 ? tree_stack[tree_top-1]->def : -1,
                            tree_stack[tree_top]->def, -1, offset, 1);
#if DEBUG_ERRORS
                    ChpegParser_print_error(self, input);
#endif
                }
#endif

                if (stack[top--] == 1) { locked = 0; } // top=s+0 (done popping)
                if (!locked) {
#if SANITY_CHECKS
                    if (tree_top < 0) {
                        pc = -1; retval = CHPEG_ERR_TREE_STACK_UNDERFLOW; break;
                    }
#endif
                    ChpegNode_pop_child(tree_stack[--tree_top]);
                }

#if VM_PRINT_TREE
                tree_changed = 1;
#endif
#ifdef CHPEG_DEFINITION_TRACE
                ++self->def_fail_count[arg];
#endif
                break;

// Choice
            case CHPEG_OP_CHOICE:
                if (top >= max_stack_size - 3) { // pushes 2 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }
                stack[++top] = tree_stack[tree_top]->num_children; // num_children - backtrack point
                stack[++top] = offset; // save offset for backtrack
                break;

            case CHPEG_OP_CISUCC: // arg = success/fail pc addr
            case CHPEG_OP_CFAIL:
#if SANITY_CHECKS
                if (top < 1) { // pops 2 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
                top -= 2;
                pc = arg;
                break;

            case CHPEG_OP_CIFAIL:
                // backtrack
                offset = stack[top];
                for (int i = tree_stack[tree_top]->num_children - stack[top-1]; i > 0; --i)
                    ChpegNode_pop_child(tree_stack[tree_top]);
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
                break;


// Repeat +
            case CHPEG_OP_RPBEG:
                if (top >= max_stack_size - 5) { // pushes 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }
#if ERRORS && ERROR_REPEAT_INHIBIT
                stack[++top] = 0; // used to inhibit error tracking after 1st rep
#endif
                stack[++top] = tree_stack[tree_top]->num_children; // num_children - backtrack point
                stack[++top] = offset; // offset - backtrack point
                stack[++top] = 0; // cnt (match count)
                break;

            case CHPEG_OP_RPMAT: // arg = loop pc addr
                ++stack[top]; // incr match count
                if (offset != stack[top-1]) { // only loop if consuming
                    stack[top-2] = tree_stack[tree_top]->num_children; // update backtrack point
                    stack[top-1] = offset; // update backtrack point
                    pc = arg; // continue looping
#if ERRORS && ERROR_REPEAT_INHIBIT
                    if (!err_locked) { // inhibit error tracking after 1st rep
                        stack[top-3] = 1; err_locked = 1;
                    }
#endif
                }
                break;

            case CHPEG_OP_RPDONE: // arg = match fail pc addr
#if SANITY_CHECKS
                if (top < 3) { // pops 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
                offset = stack[top-1];
                for (int i = tree_stack[tree_top]->num_children - stack[top-2]; i > 0; --i)
                    ChpegNode_pop_child(tree_stack[tree_top]);
                if (stack[top] > 0) { // op+ SUCCESS
                    top -= 3;
                }
                else { // op+ FAIL
                    top -= 3;
                    pc = arg;
                }
#if ERRORS && ERROR_REPEAT_INHIBIT
                if (stack[top--]) { err_locked = 0; } // reenable error tracking (if we disabled it)
#endif
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
                break;

// Repeat *|?
            case CHPEG_OP_RSBEG:
            case CHPEG_OP_RQBEG:
                if (top >= max_stack_size - 4) { // pushes 3 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }
#if ERRORS && ERROR_REPEAT_INHIBIT
                if (!err_locked) { // inhibit error tracking
                    stack[++top] = 1; err_locked = 1;
                }
                else {
                    stack[++top] = 0;
                }
#endif
                stack[++top] = tree_stack[tree_top]->num_children; // num_children - backtrack point
                stack[++top] = offset; // save offset for backtrack
                break;

            case CHPEG_OP_RSMAT: // arg = loop pc addr
                if (offset != stack[top]) { // only loop if consuming
                    stack[top-1] = tree_stack[tree_top]->num_children; // update backtrack point
                    stack[top] = offset; // update backtrack point
                    pc = arg; // continue looping
                } // else next instruction, which is a R*DONE
                break;

            case CHPEG_OP_RSDONE: // * always succeeds, proceeds to next instr.
            case CHPEG_OP_RQDONE: // ? always succeeds, proceeds to next instr.
#if SANITY_CHECKS
                if (top < 2) { // pops 3 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
                offset = stack[top];
                for (int i = tree_stack[tree_top]->num_children - stack[top-1]; i > 0; --i)
                    ChpegNode_pop_child(tree_stack[tree_top]);
                top -= 2;
#if ERRORS && ERROR_REPEAT_INHIBIT
                if (stack[top--]) { err_locked = 0; } // reenable error tracking (if we disabled it)
#endif
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
                break;

// Repeat ?
            case CHPEG_OP_RQMAT: // no looping for ?
                stack[top-1] = tree_stack[tree_top]->num_children; // update backtrack point
                stack[top] = offset; // update backtrack point
                break;

#ifdef CHPEG_EXTENSIONS
//
// Trim
//
            case CHPEG_OP_TRIM: // TRIM start ('<')
                                // arg: unused

                if (top >= max_stack_size - 5) { // pushes 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }

                // Save original offset and flags
                stack[++top] = tree_stack[tree_top]->offset;
                stack[++top] = tree_stack[tree_top]->flags;

                // Trim on left (set offset and mark as 'trimmed left')
                tree_stack[tree_top]->offset = offset;
                tree_stack[tree_top]->flags |= CHPEG_FLAG_TRIMMED_LEFT;

                // Save changed offset and flags on the stack
                stack[++top] = tree_stack[tree_top]->offset;
                stack[++top] = tree_stack[tree_top]->flags;

                break;

            case CHPEG_OP_TRIMS: // TRIM Success ('>'): the contents inside ('<' ... '>') matched
                                 // arg = next pc

                if (top < 3) { // pops 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }

                // Restore the changed flags and offset values from the stack
                tree_stack[tree_top]->flags = stack[top--];
                tree_stack[tree_top]->offset = stack[top--];

                // Trim of right (set length and mark as 'trimmed right')
                tree_stack[tree_top]->length = offset - tree_stack[tree_top]->offset;
                tree_stack[tree_top]->flags |= CHPEG_FLAG_TRIMMED_RIGHT;

                // Discard the original flags and offset values saved on stack
                top -= 2;

                pc = arg;
                break;

            case CHPEG_OP_TRIMF: // TRIM Failed ('>'): the contents inside ('<' ... '>') did not match
                                 // arg = next pc

                if (top < 3) { // pops 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }

                // Discard the changed flags and offset values saved on stack
                top -= 2;

                // Restore the original flags and offset values from the stack
                tree_stack[tree_top]->flags = stack[top--];
                tree_stack[tree_top]->offset = stack[top--];

                pc = arg;
                break;
#endif

// Predicate
            case CHPEG_OP_PREDA:
            case CHPEG_OP_PREDN:
                // Predicate begin, should be followed with child instructions,
                // then PMATCH{S,F}, then PNOMAT{S,F}, depending on op (&,!)
                if (top >= max_stack_size - 5) { // pushes 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_OVERFLOW; break;
                }
                stack[++top] = tree_stack[tree_top]->num_children; // num_children - backtrack point
                stack[++top] = offset; // save offset for backtrack
#if ERRORS
#if ERRORS_PRED
                stack[++top] = pc + 1; // 1st child inst address for error
#endif
                if (!err_locked) {
                    stack[++top] = 1; err_locked = 1;
                }
                else {
                    stack[++top] = 0;
                }
#endif
                break;

            case CHPEG_OP_PMATCHF: // Predicate matched, match is considered failure, arg = failure address
            case CHPEG_OP_PNOMATF: // Predicate not matched, not match is considered failure, arg = failure address
#if ERRORS && ERRORS_PRED
                if (stack[top]) {
                    ChpegParser_expected(self,
                            tree_top > 0 ? tree_stack[tree_top-1]->def : -1,
                            tree_stack[tree_top]->def, instructions[stack[top-1]],
                            offset, (CHPEG_OP_PNOMATF == op));
#if DEBUG_ERRORS
                    ChpegParser_print_error(self, input);
#endif
                }
#endif
                pc = arg;
                goto pred_cleanup;

            case CHPEG_OP_PMATCHS: // Predicate matched, match is considered success; next instruction skipped
                ++pc;
                // passthrough to pred_cleanup

            case CHPEG_OP_PNOMATS: // Predicate not matched, not match is considered success
pred_cleanup:
#if SANITY_CHECKS
                if (top < 3) { // pops 4 items
                    pc = -1; retval = CHPEG_ERR_STACK_UNDERFLOW; break;
                }
#endif
#if ERRORS
                if (stack[top--]) { err_locked = 0; }
#if ERRORS_PRED
                --top;
#endif
#endif
                offset = stack[top--]; // restore saved offset (don't consume)
                for (int i = tree_stack[tree_top]->num_children - stack[top--]; i > 0; --i)
                    ChpegNode_pop_child(tree_stack[tree_top]);
#if VM_PRINT_TREE
                tree_changed = 1;
#endif
                break;

// CharClass
            case CHPEG_OP_CHRCLS: // arg = str_id; match CharClass; skip next instruction on match
                {
                    if (offset < length) {
                        int mlen = str_len[arg], i;
                        const unsigned char *mstr = strings[arg];
                        for (i = 0; i < mlen; ++i) {
                            if (mstr[i] == input[offset]) {
                                ++offset;
                                ++pc;
                                break;
                            }
                            if ((i < mlen - 2) && (mstr[i+1] == '-')) {
                                if ((input[offset] >= mstr[i]) && (input[offset] <= mstr[i+2])) {
                                    ++offset;
                                    ++pc;
                                    break;
                                }
                                i+=2;
                            }
                        }
                        if (i < mlen) break;
                    }
#if ERRORS && ERRORS_TERMINALS
                    if (!err_locked) {
                        ChpegParser_expected(self,
                                tree_top > 0 ? tree_stack[tree_top-1]->def : -1,
                                tree_stack[tree_top]->def, instructions[pc], offset, 1);
#if DEBUG_ERRORS
                        ChpegParser_print_error(self, input);
#endif
                    }
#endif
                }
                break;

// Literal
            case CHPEG_OP_LIT: // arg = str_id; match literal string; skip next instruction on match
#ifdef CHPEG_HAS_NOCASE
            case CHPEG_OP_LIT_NC:
#endif /*CHPEG_OP(NOCASE)*/
                {
                    int len = str_len[arg];
                    if ((offset < (length - (len - 1))) && !(
#ifdef CHPEG_HAS_NOCASE
			    (op == CHPEG_OP_LIT_NC) ? strncasecmp((const char*)&input[offset], (const char*)strings[arg], len) :
#endif /*CHPEG_OP(NOCASE)*/
					memcmp(&input[offset], strings[arg], len))) {
                        offset += len;
                        ++pc;
                        break;
                    }
                }
#if ERRORS && ERRORS_TERMINALS
                if (!err_locked) {
                    ChpegParser_expected(self,
                            tree_top > 0 ? tree_stack[tree_top-1]->def : -1,
                            tree_stack[tree_top]->def, instructions[pc], offset, 1);
#if DEBUG_ERRORS
                    ChpegParser_print_error(self, input);
#endif
                }
#endif
                break;

// Dot
            case CHPEG_OP_DOT: // arg = fail addr; match any char; goto addr on failure
                if (offset < length) { offset++; break; }
#if ERRORS && ERRORS_TERMINALS
                if (!err_locked) {
                    ChpegParser_expected(self,
                            tree_top > 0 ? tree_stack[tree_top-1]->def : -1,
                            tree_stack[tree_top]->def, instructions[pc], offset, 1);
#if DEBUG_ERRORS
                    ChpegParser_print_error(self, input);
#endif
                }
#endif
                pc = arg;
                break;

// End
            case CHPEG_OP_SUCC: // overall success
                pc = -1; // we're done
#if SANITY_CHECKS
                if (tree_top < 0) {
                    retval = CHPEG_ERR_TREE_STACK_UNDERFLOW; break;
                }
#endif
                tree_stack[tree_top]->length = offset - tree_stack[tree_top]->offset;
                --tree_top;

                // clean up the parse tree, reversing the reverse node insertion in the process
                self->tree_root = ChpegNode_unwrap(self->tree_root);
#if VM_PRINT_TREE
                tree_changed = 1;
#endif

                if (top != -1) {
                    retval = CHPEG_ERR_UNEXPECTED_STACK_DATA;
                }
                else if (tree_top != -1) {
                    retval = CHPEG_ERR_UNEXPECTED_TREE_STACK_DATA;
                }
                else {
                    if (consumed != NULL) {
                        *consumed = offset;
                    }
                    if (offset == length) {
                        retval = 0;
                    }
                    else {
                        retval = CHPEG_ERR_EXTRANEOUS_INPUT;
                    }
                }
                break;

            case CHPEG_OP_FAIL: // overall failure
                pc = -1; // we're done
                retval = arg < 0 ? arg : CHPEG_ERR_PARSE_FAILED;
                break;

            default:
                pc = -1; // we're done
                retval = CHPEG_ERR_UNKNOWN_INSTRUCTION;
                break;
        }

#if VM_PRINT_TREE
        if (self->vm_print_tree && tree_changed) {
            ChpegParser_print_tree(self, input, stderr);
        }
#endif
        if (pc < 0) {
            self->parse_result = retval;
            return retval;
        }
    }

    retval = CHPEG_ERR_RUNAWAY;
    self->parse_result = retval;
    return retval;
}

// } chpeg: parser.c

//
// chpeg: compiler.c {
//

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#ifndef CHPEG_AMALGAMATION
#include "chpeg/util.h"
#include "chpeg/parser.h"
#include "chpeg/compiler.h"
#include "chpeg/opcodes.h"
#include "chpeg/chpeg_bytecode.h"
#endif

#ifndef DEBUG_COMPILER
#define DEBUG_COMPILER 0
#endif

#ifndef CHPEG_BC
#define CHPEG_BC(bc) CHPEG_BC_##bc
#endif /*CHPEG_BC*/

//
// Gnode: grammar tree node (internal use during compilation)
// FIXME: probably more of a 'compilation unit node'
//

typedef struct _ChpegGNode
{
    ChpegNode *node;
    int type;

    int parse_state;
    int parent_next_state;
    int parent_fail_state;

    union {
        unsigned char cval[4];
        int ival;
    } val;
    int value_len;

    int num_children;
    struct _ChpegGNode *head;
    struct _ChpegGNode *next;
    struct _ChpegGNode *parent;
} ChpegGNode;

static ChpegGNode *ChpegGNode_new()
{
    ChpegGNode *self = (ChpegGNode *)CHPEG_CALLOC(1, sizeof(ChpegGNode));

    self->type = -1;

    self->parse_state = -1;
    self->parent_next_state = -1;
    self->parent_fail_state = -1;

    return self;
}

static void ChpegGNode_free(ChpegGNode *self)
{
    if (self == NULL) return;

    ChpegGNode *tmp;
    for (ChpegGNode *p = self->head; p; p = tmp) {
        tmp = p->next;
        ChpegGNode_free(p);
    }
    self->head = NULL;
    CHPEG_FREE(self);
}

static ChpegGNode *ChpegGNode_push_child(ChpegGNode *self, ChpegGNode *child)
{
    child->parent = self;
    child->next = self->head;
    self->head = child;
    ++(self->num_children);
    return child;
}

// unused
#if 0
static void ChpegGNode_pop_child(ChpegGNode *self)
{
    if (self->head) {
        ChpegGNode *tmp = self->head;
        self->head = self->head->next;
        ChpegGNode_free(tmp);
        --(self->num_children);
    }
}
#endif

static ChpegGNode *ChpegGNode_reverse(ChpegGNode *self)
{
    ChpegGNode *p = self->head; self->head = NULL;
    ChpegGNode *tmp;
    for (; p; p=tmp) {
        tmp = p->next;
        p = ChpegGNode_reverse(p);
        p->next = self->head;
        self->head = p;
    }
    return self;
}

//
// Compiler
//

typedef struct _ChpegCU
{
    ChpegParser *parser;
    const unsigned char *input;
    ChpegByteCode *bc;
    ChpegGNode *root;
    int strings_allocated;
} ChpegCU;

#ifdef CHPEG_EXTENSIONS
static int ChpegCU_find_def_node(ChpegCU *cu, ChpegGNode *gnode, ChpegGNode **def_return)
{
    ChpegGNode *parent = gnode;

    for (; parent && parent != cu->root; parent = parent->parent) {
        if (parent->type == CHPEG_BC(DEFINITION)) {
            if (def_return) {
                *def_return = parent;
            }
            return 0;
        }
    }
    if (def_return) {
        *def_return = NULL;
    }
    return 1;
}
#endif

#if DEBUG_COMPILER
static void ChpegCU_print(ChpegCU *cu, ChpegGNode *gnode, const unsigned char *input, int depth)
{
    int flags = 0;
    char *data = NULL;
    const char *def_name = ChpegByteCode_def_name(cu->parser->bc, gnode->type);

    ChpegNode *node = gnode->node;
    if (node) {
        data = chpeg_esc_bytes(&input[node->offset], node->length, 40);
        flags = node->flags;
    }

    if (depth == 0) {
        printf("---------------------------------------------------------------------------------\n");
        printf(" Begin    Len  DefID    Parse  PNext  PFail  Flags  Def. Name / Data\n");
        printf("---------------------------------------------------------------------------------\n");
    }
    printf("%6zu %6zu %6d | %6d %6d %6d | %s%s%s | %*s%s \"%s\"\n",
        node ? node->offset : -1,
        node ? node->length : -1,
        gnode->type,
        gnode->parse_state,
        gnode->parent_next_state,
        gnode->parent_fail_state,
        flags & CHPEG_FLAG_STOP ? "S" : " ",
        flags & CHPEG_FLAG_IGNORE ? "I" : " ",
        flags & CHPEG_FLAG_LEAF ? "L" : " ",
        depth * 2, "",
        def_name ? def_name : "<N/A>",
        data ? data : ""
        );
    if (data) { CHPEG_FREE(data); data = NULL; }

    for (ChpegGNode *p = gnode->head; p; p = p->next) {
        ChpegCU_print(cu, p, input, depth + 1);
    }
}
#endif

static void ChpegCU_setup_defs(ChpegCU *cu)
{
    ChpegNode *p = NULL;
    int i = 0, j = 0;

    cu->bc->num_defs = cu->parser->tree_root->num_children;
#if DEBUG_COMPILER
    printf("ChpegCU_setup_defs: num_defs=%d\n", cu->bc->num_defs);
#endif

    cu->bc->def_names = (char **)CHPEG_MALLOC(cu->bc->num_defs * sizeof(char *));
    cu->bc->def_flags = (int *)CHPEG_MALLOC(cu->bc->num_defs * sizeof(int));
    cu->bc->def_addrs = (int *)CHPEG_MALLOC(cu->bc->num_defs * sizeof(int));

    for (p = cu->parser->tree_root->head, i = 0; p; p = p->next, ++i) {
        if (CHPEG_BC(DEFINITION) != p->def) { continue; }

        ChpegNode *tmp = p->head; // Identifier, definition name
        if (NULL == tmp || CHPEG_BC(IDENTIFIER) != tmp->def) { continue; }
        cu->bc->def_names[i] = (char *)CHPEG_MALLOC(1 + tmp->length);
        memcpy(cu->bc->def_names[i], &cu->input[tmp->offset], tmp->length);
        cu->bc->def_names[i][tmp->length] = '\0';

        int flags = 0;
        tmp = tmp->next; // Options, flags
        if (NULL != tmp && CHPEG_BC(OPTIONS) == tmp->def) {
            for (j = 0; j < tmp->length; ++j) {
                switch(cu->input[tmp->offset + j]) {
                    case 'S': flags |= CHPEG_FLAG_STOP; break;
                    case 'I': flags |= CHPEG_FLAG_IGNORE; break;
                    case 'L': flags |= CHPEG_FLAG_LEAF; break;
                }
            }
            p->head->next = tmp->next; // eliminate OPTIONS node
            ChpegNode_free(tmp);
        }
        cu->bc->def_flags[i] = flags;
#if DEBUG_COMPILER
        printf("Compile_setup_defs: def[%i]: name=%s flags=%d\n", i, cu->bc->def_names[i], cu->bc->def_flags[i]);
#endif
    }
}

static void ChpegCU_setup_def_addrs(ChpegCU *cu)
{
    int i = 0;
    ChpegGNode *p = NULL;
    for (i = 0, p = cu->root->head; p; p = p->next, ++i) {
        cu->bc->def_addrs[i] = p->head->next->parse_state - 1;
    }
}

static int ChpegCU_find_def(ChpegCU *cu, ChpegNode *ident)
{
    for (int i = 0; i < cu->bc->num_defs; ++i) {
        if (ident->length == strlen(cu->bc->def_names[i]) &&
            0 == memcmp(cu->input + ident->offset, cu->bc->def_names[i], ident->length))
        {
            return i;
        }
    }
    return -1;
}

static void ChpegCU_build_tree(ChpegCU *cu, ChpegNode *np, ChpegGNode *gp)
{
    if (NULL == np) { np = cu->parser->tree_root; }
    if (NULL == gp) { gp = cu->root; }
    gp->node = np;
    gp->type = np->def;
    for (ChpegNode *p = np->head; p; p = p->next) {
        ChpegGNode *g = ChpegGNode_new();
        ChpegCU_build_tree(cu, p, g);
        ChpegGNode_push_child(gp, g);
    }
}

// TODO: count in cu not bc
static inline int ChpegCU_alloc_inst(ChpegCU *cu)
{
    return cu->bc->num_instructions++;
}

static void ChpegCU_alloc_instructions(ChpegCU *cu, ChpegGNode *gp)
{
    switch (gp->type) {
        case CHPEG_BC(GRAMMAR):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_inst(cu);
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_alloc_instructions(cu, p);
            }
            break;
        case CHPEG_BC(DEFINITION):
            ChpegCU_alloc_instructions(cu, gp->head->next);
            gp->head->next->parent_next_state = ChpegCU_alloc_inst(cu);
            gp->head->next->parent_fail_state = ChpegCU_alloc_inst(cu);
            break;
        case CHPEG_BC(CHOICE):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_alloc_instructions(cu, p);
                p->parent_next_state = ChpegCU_alloc_inst(cu);
                p->parent_fail_state = ChpegCU_alloc_inst(cu);
            }
            ChpegCU_alloc_inst(cu);
            break;
        case CHPEG_BC(SEQUENCE):
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_alloc_instructions(cu, p);
            }
            gp->parse_state = gp->head->parse_state;
            break;
#ifdef CHPEG_EXTENSIONS
        case CHPEG_BC(TRIM):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_instructions(cu, gp->head);
            gp->head->parent_next_state = ChpegCU_alloc_inst(cu);
            gp->head->parent_fail_state = ChpegCU_alloc_inst(cu);
            break;
#endif
        case CHPEG_BC(REPEAT):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_instructions(cu, gp->head);
            gp->head->parent_next_state = ChpegCU_alloc_inst(cu);
            gp->head->parent_fail_state = ChpegCU_alloc_inst(cu);
            break;
        case CHPEG_BC(PREDICATE):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_instructions(cu, gp->head->next);
            gp->head->next->parent_next_state = ChpegCU_alloc_inst(cu);
            gp->head->next->parent_fail_state = ChpegCU_alloc_inst(cu);
            break;
        case CHPEG_BC(DOT):
            gp->parse_state = ChpegCU_alloc_inst(cu);
            break;
        case CHPEG_BC(IDENTIFIER):
        case CHPEG_BC(CHARCLASS):
        case CHPEG_BC(LITERAL):
#ifdef CHPEG_HAS_NOCASE
        //case CHPEG_BC(LITERALSQ):
        //case CHPEG_BC(LITERALDQ):
#endif /*CHPEG_OP(NOCASE)*/
            gp->parse_state = ChpegCU_alloc_inst(cu);
            ChpegCU_alloc_inst(cu);
            break;
    }
}

// TODO: move to ChpegByteCode
static inline void ChpegCU_add_inst(ChpegCU *cu, int inst)
{
    cu->bc->instructions[cu->bc->num_instructions++] = inst;
}

static void ChpegCU_add_instructions(ChpegCU *cu, ChpegGNode *gp)
{
    int def = 0;
    switch (gp->type) {
        case CHPEG_BC(GRAMMAR):
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_IDENT, 0));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_FAIL, 0));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_SUCC, 0));
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_add_instructions(cu, p);
            }
            break;
        case CHPEG_BC(DEFINITION):
            def = ChpegCU_find_def(cu, gp->head->node);
            ChpegCU_add_instructions(cu, gp->head->next);
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_ISUCC, def));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_IFAIL, def));
            break;
        case CHPEG_BC(CHOICE):
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_CHOICE, 0));
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_add_instructions(cu, p);
                ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_CISUCC, gp->parent_next_state - 1));
                ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_CIFAIL, 0));
            }
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_CFAIL, gp->parent_fail_state - 1));
            break;
        case CHPEG_BC(SEQUENCE):
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                p->parent_next_state = p->next ? p->next->parse_state : gp->parent_next_state;
                p->parent_fail_state = gp->parent_fail_state;
                ChpegCU_add_instructions(cu, p);
            }
            break;
#ifdef CHPEG_EXTENSIONS
        case CHPEG_BC(TRIM):
            {
                ChpegGNode *def_node;
                def = -1;
                if (0 == ChpegCU_find_def_node(cu, gp, &def_node)) {
                    def = ChpegCU_find_def(cu, def_node->head->node);
                }
            }
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_TRIM, def)); // arg def is informational only
            ChpegCU_add_instructions(cu, gp->head);
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_TRIMS, gp->parent_next_state - 1));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_TRIMF, gp->parent_fail_state - 1));
            break;
#endif
        case CHPEG_BC(REPEAT):
            {
                unsigned char op = cu->input[gp->head->next->node->offset];
                switch (op) {
                    case '+':
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RPBEG, 0));
                        ChpegCU_add_instructions(cu, gp->head);
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RPMAT, gp->head->parse_state - 1));
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RPDONE, gp->parent_fail_state - 1));
                        break;
                    case '*':
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RSBEG, 0));
                        ChpegCU_add_instructions(cu, gp->head);
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RSMAT, gp->head->parse_state - 1));
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RSDONE, 0));
                        break;
                    case '?':
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RQBEG, 0));
                        ChpegCU_add_instructions(cu, gp->head);
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RQMAT, 0));
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_RQDONE, 0));
                        break;
                }
            }
            break;
        case CHPEG_BC(PREDICATE):
            {
                unsigned char op = cu->input[gp->head->node->offset];
                switch (op) {
                    case '&':
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PREDA, 0));
                        ChpegCU_add_instructions(cu, gp->head->next);
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PMATCHS, gp->parent_fail_state - 1));
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PNOMATF, gp->parent_fail_state - 1));
                        break;
                    case '!':
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PREDN, 0));
                        ChpegCU_add_instructions(cu, gp->head->next);
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PMATCHF, gp->parent_fail_state - 1));
                        ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_PNOMATS, gp->parent_fail_state - 1));
                        break;
                }
            }
            break;
        case CHPEG_BC(DOT):
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_DOT, gp->parent_fail_state - 1));
            break;
        case CHPEG_BC(IDENTIFIER):
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_IDENT, ChpegCU_find_def(cu, gp->node)));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_GOTO, gp->parent_fail_state - 1));
            break;
        case CHPEG_BC(CHARCLASS):
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_CHRCLS, gp->val.ival));
            ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_GOTO, gp->parent_fail_state - 1));
            break;
        case CHPEG_BC(LITERAL):
            {
                int literal_op = CHPEG_OP_LIT;
#ifdef CHPEG_HAS_NOCASE
        //case CHPEG_BC(LITERALSQ):
        //case CHPEG_BC(LITERALDQ):
                for (ChpegGNode *p = gp->head; p; p = p->next) {
                    if(p->node->def == CHPEG_BC(NOCASE))
                        literal_op = CHPEG_OP_LIT_NC;
                }
#endif /*CHPEG_HAS_NOCASE*/
                ChpegCU_add_inst(cu, CHPEG_INST(literal_op, gp->val.ival));
                ChpegCU_add_inst(cu, CHPEG_INST(CHPEG_OP_GOTO, gp->parent_fail_state - 1));
            }
            break;
    }
}

static int ChpegCU_alloc_string(ChpegCU *cu, const unsigned char *str, int len)
{
    for (int i = 0; i < cu->bc->num_strings; ++i) {
        if (len == cu->bc->str_len[i] && 0 == memcmp(cu->bc->strings[i], str, len)) {
            return i;
        }
    }
    if (NULL == cu->bc->strings) {
        cu->bc->num_strings = 0;
        cu->strings_allocated = 16;
        cu->bc->strings = (unsigned char **)CHPEG_MALLOC(cu->strings_allocated * sizeof(unsigned char *));
        cu->bc->str_len = (int *)CHPEG_MALLOC(cu->strings_allocated * sizeof(int));
    }
    if (cu->bc->num_strings == cu->strings_allocated) {
        cu->strings_allocated *= 2;
        cu->bc->strings = (unsigned char **)CHPEG_REALLOC(cu->bc->strings, cu->strings_allocated * sizeof(unsigned char *));
        cu->bc->str_len = (int *)CHPEG_REALLOC(cu->bc->str_len, cu->strings_allocated * sizeof(int));
    }
    int idx = cu->bc->num_strings++;
    cu->bc->strings[idx] = (unsigned char *)CHPEG_MALLOC(len + 1);
    memcpy(cu->bc->strings[idx], str, len);
    cu->bc->strings[idx][len] = '\0'; // safety
    cu->bc->str_len[idx] = len;
    return idx;
}

static void ChpegCU_alloc_strings(ChpegCU *cu, ChpegGNode *gp)
{
    switch (gp->type) {
#ifdef CHPEG_HAS_NOCASE
        //case CHPEG_BC(LITERALSQ):
        //case CHPEG_BC(LITERALDQ):
#endif /*CHPEG_HAS_NOCASE*/
        case CHPEG_BC(LITERAL):
        case CHPEG_BC(CHARCLASS):
            {
                int len = 0, offset = 0;
                for (ChpegGNode *p = gp->head; p; p = p->next) {
                    ChpegCU_alloc_strings(cu, p);
                    len += p->value_len;
                }
                unsigned char *str = (unsigned char *)CHPEG_MALLOC(len);
                for (ChpegGNode *p = gp->head; p; p = p->next) {
                    memcpy(str+offset, p->val.cval, p->value_len);
                    offset += p->value_len;
                }
                gp->val.ival = ChpegCU_alloc_string(cu, str, len);
#if DEBUG_COMPILER
                char *tmp = chpeg_esc_bytes(str, len, 20);
                printf("PEG BC_LITERAL/CHARCLASS %s %d\n", tmp, gp->val.ival);
                CHPEG_FREE(tmp);
#endif
                CHPEG_FREE(str);
            }
            break;
        case CHPEG_BC(CHARRANGE):
            {
                for (ChpegGNode *p = gp->head; p; p = p->next) {
                    ChpegCU_alloc_strings(cu, p);
                }
                gp->val.cval[0] = gp->head->val.cval[0];
                gp->val.cval[1] = '-';
                gp->val.cval[2] = gp->head->next->val.cval[0];
                gp->value_len = 3;
#if DEBUG_COMPILER
                char *tmp = chpeg_esc_bytes(gp->val.cval, gp->value_len, 10);
                printf("CHPEG_BC_CHARRANGE %s\n", tmp);
                CHPEG_FREE(tmp);
#endif
            }
            break;
        case CHPEG_BC(PLAINCHAR):
            {
                gp->val.cval[0] = cu->input[gp->node->offset];
                gp->value_len = 1;
#if DEBUG_COMPILER
                char *tmp = chpeg_esc_bytes(gp->val.cval, gp->value_len, 10);
                printf("CHPEG_BC_PLAINCHAR %s\n", tmp);
                CHPEG_FREE(tmp);
#endif
            }
            break;
        case CHPEG_BC(ESCCHAR):
            {
                gp->val.cval[0] = cu->input[gp->node->offset + 1];
                gp->value_len = 1;
                switch (gp->val.cval[0]) {
#ifdef CHPEG_HAS_EXTRA_ESCAPE
                    case 'a': gp->val.cval[0] = '\a'; break;
                    case 'b': gp->val.cval[0] = '\b'; break;
                    case 'e': gp->val.cval[0] = '\e'; break;
                    case 'f': gp->val.cval[0] = '\f'; break;
                    case 'v': gp->val.cval[0] = '\v'; break;
#endif
                    case 'n': gp->val.cval[0] = '\n'; break;
                    case 'r': gp->val.cval[0] = '\r'; break;
                    case 't': gp->val.cval[0] = '\t'; break;
                }
#if DEBUG_COMPILER
                char *tmp = chpeg_esc_bytes(gp->val.cval, gp->value_len, 10);
                printf("CHPEG_BC_ESCCHAR %s\n", tmp);
                CHPEG_FREE(tmp);
#endif
            }
            break;
        case CHPEG_BC(OCTCHAR):
            {
                int val = 0; int len = gp->node->length - 1;
                const unsigned char *ip = cu->input + gp->node->offset + 1;
                for (int i = 0; i < len; ++i) {
                    val = (val << 3) | (ip[i] - '0');
                }
                gp->val.cval[0] = val & 255;
                gp->value_len = 1;
#if DEBUG_COMPILER
                char *tmp = chpeg_esc_bytes(gp->val.cval, gp->value_len, 10);
                printf("CHPEG_BC_OCTCHAR %s\n", tmp);
                CHPEG_FREE(tmp);
#endif
            }
            break;
#ifdef CHPEG_HAS_HEXCHAR
        case CHPEG_BC(HEXCHAR):
            {
                int val = 0; int len = gp->node->length - 1;
                const unsigned char *ip = cu->input + gp->node->offset + 1;
                for (int i = 1; i < len; ++i) {
                    unsigned char c = ip[i];
                    switch(c) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                            c -= '0';
                            break;

                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                            c = 10 + (c - 'a');
                            break;

                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                            c = 10 + (c - 'A');
                            break;
                    }
                    val = (val << 4) | c;
                }
                gp->val.cval[0] = val & 255;
                gp->value_len = 1;
#if DEBUG_COMPILER
                unsigned char *tmp = esc_string(gp->val.cval, gp->value_len, 10);
                printf("CHPEG_BC_HEXCHAR %s\n", tmp);
                CHPEG_FREE(tmp);
#endif
            }
            break;
#endif /*CHPEG_HAS_HEXCHAR*/
        default:
            for (ChpegGNode *p = gp->head; p; p = p->next) {
                ChpegCU_alloc_strings(cu, p);
            }
            break;
    }
}

// This is more of a convenience function, thus the lowercase chpeg_ prefix.
// I plan to create a more OO-like API to the compiler to allow more flexibility.
// verbose is a bit field: 1: info | 2: print parse tree | 1<<15: disable errors
CHPEG_API int chpeg_compile(const unsigned char *input, size_t length,
    ChpegByteCode **bytecode_return, int verbose)
{
    ChpegCU cu;

    cu.parser = ChpegParser_new(chpeg_default_bytecode());
    cu.input = input;
    cu.bc = NULL;
    cu.root = NULL;
    cu.strings_allocated = 0;

    size_t consumed = 0;
    int parse_result = ChpegParser_parse(cu.parser, input, length, &consumed);

    if (parse_result == 0) {
        if (verbose & 1) {
            fprintf(stderr, "chpeg_compile: Parse successful.\n");
        }
        if (verbose & 2) {
            ChpegParser_print_tree(cu.parser, input, stderr);
        }
    }
    else {
        if ((verbose & (1<<15)) == 0) {
            if (parse_result == CHPEG_ERR_EXTRANEOUS_INPUT) {
                fprintf(stderr, "chpeg_compile: Extraneous input: "
                    "parse consumed %lu bytes out of %lu\n", consumed, length);
            }
            else {
                fprintf(stderr, "chpeg_compile: Parse failed with result: %d\n",
                    parse_result);
            }
            ChpegParser_print_error(cu.parser, input);
        }
        goto done;
    }

    cu.bc = ChpegByteCode_new();
    ChpegCU_setup_defs(&cu);

    cu.root = ChpegGNode_new();

    ChpegCU_build_tree(&cu, NULL, NULL);
    ChpegGNode_reverse(cu.root);

    ChpegCU_alloc_strings(&cu, cu.root);

    ChpegCU_alloc_instructions(&cu, cu.root);
#if DEBUG_COMPILER
    printf("instructions alloc'd: %d\n", cu.bc->num_instructions);
#endif
    cu.bc->instructions = (int *)CHPEG_CALLOC(cu.bc->num_instructions, sizeof(int));

    cu.bc->num_instructions = 0;
    ChpegCU_add_instructions(&cu, cu.root);
#if DEBUG_COMPILER
    printf("instructions after add: %d\n", cu.bc->num_instructions);
#endif

    ChpegCU_setup_def_addrs(&cu);

#if DEBUG_COMPILER
    ChpegCU_print(&cu, cu.root, input, 0);
#endif

done:
    if (cu.parser) { ChpegParser_free(cu.parser); }
    if (cu.root) { ChpegGNode_free(cu.root); }
    if (bytecode_return) {
        *bytecode_return = cu.bc;
    }
    return parse_result;
}

#ifndef CHPEG_DEFAULT_BYTECODE
#define CHPEG_DEFAULT_BYTECODE (&chpeg_bytecode)
#endif
CHPEG_API const ChpegByteCode *chpeg_default_bytecode()
{
    return CHPEG_DEFAULT_BYTECODE;
}

// } chpeg: compiler.c

